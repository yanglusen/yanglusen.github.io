<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅析Angular中的文件上传进度监控</title>
    <link href="/posts/e42f4a99/"/>
    <url>/posts/e42f4a99/</url>
    
    <content type="html"><![CDATA[<p>最近老是跟文件上传打交道，趁着搞完需求的间隙，整理一下拖了好久的文章，浅析 Angular 中的文件上传进度监控的原理。其主要的核心是利用了 XMLHttpRequest 和 Observable 对象来实现的。</p><h3 id="文件上传源码">文件上传源码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上传单个文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> uploadFile 上传文件对象</span><br><span class="hljs-comment">     */</span><br>    upload(uploadFile: ThyUploadFile): Observable&lt;ThyUploadResponse&gt; &#123;<br>        <span class="hljs-keyword">this</span>.ensureFileName(uploadFile);<br><br>        <span class="hljs-keyword">return</span> new Observable(observer =&gt; &#123;<br>            <span class="hljs-keyword">const</span> &#123; xhr, cleanup &#125; = <span class="hljs-keyword">this</span>.uploadByXhr(observer, uploadFile);<br>            <span class="hljs-keyword">return</span> () =&gt; &#123;<br>                cleanup();<br><br>                <span class="hljs-keyword">if</span> (xhr.readyState !== xhr.DONE) &#123;<br>                    xhr.abort();<br>                &#125;<br>            &#125;;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">uploadByXhr</span>(<span class="hljs-params">observer: Subscriber&lt;ThyUploadResponse&gt;, uploadFile: ThyUploadFile</span>)</span> &#123;<br>        <span class="hljs-comment">// 注入 XhrFactory,调用其 build() 方法，返回 XMLHttpRequest 对象</span><br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-built_in">this</span>.xhrFactory.build();<br>        <span class="hljs-keyword">const</span> time: <span class="hljs-built_in">number</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>        <span class="hljs-keyword">let</span> speed = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> estimatedTime: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>        uploadFile.progress = &#123;<br>            <span class="hljs-attr">status</span>: ThyUploadStatus.started,<br>            <span class="hljs-attr">percentage</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">startTime</span>: time<br>        &#125;;<br><br>        <span class="hljs-keyword">const</span> onProgress = (event: ProgressEvent): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (event.lengthComputable) &#123;<br>                <span class="hljs-keyword">let</span> percentage = <span class="hljs-built_in">Math</span>.round((event.loaded * <span class="hljs-number">100</span>) / event.total);<br>                <span class="hljs-keyword">if</span> (percentage === <span class="hljs-number">100</span>) &#123;<br>                    percentage = <span class="hljs-number">99</span>;<br>                &#125;<br>                <span class="hljs-keyword">const</span> diff = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - time;<br>                speed = <span class="hljs-built_in">Math</span>.round((event.loaded / diff) * <span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">const</span> progressStartTime = (uploadFile.progress &amp;&amp; uploadFile.progress.startTime) || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>                estimatedTime = <span class="hljs-built_in">Math</span>.ceil((event.total - event.loaded) / speed);<br><br>                uploadFile.progress.status = ThyUploadStatus.uploading;<br>                uploadFile.progress.percentage = percentage;<br>                uploadFile.progress.speed = speed;<br>                uploadFile.progress.speedHuman = <span class="hljs-string">`<span class="hljs-subst">$&#123;humanizeBytes(speed, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>)&#125;</span>/s`</span>;<br>                uploadFile.progress.startTime = progressStartTime;<br>                uploadFile.progress.estimatedTime = estimatedTime;<br>                uploadFile.progress.estimatedTimeHuman = <span class="hljs-built_in">this</span>.secondsToHuman(estimatedTime);<br><br>                observer.next(&#123; <span class="hljs-attr">status</span>: ThyUploadStatus.uploading, <span class="hljs-attr">uploadFile</span>: uploadFile &#125;);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">const</span> onError = <span class="hljs-function">(<span class="hljs-params">error: ErrorEvent</span>) =&gt;</span> observer.error(error);<br><br>        <span class="hljs-keyword">const</span> onReadyStateChange = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (xhr.readyState === XMLHttpRequest.DONE) &#123;<br>                <span class="hljs-keyword">const</span> speedTime = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - uploadFile.progress.startTime) * <span class="hljs-number">1000</span>;<br>                <span class="hljs-keyword">const</span> speedAverage = <span class="hljs-built_in">Math</span>.round(uploadFile.nativeFile.size / speedTime);<br><br>                uploadFile.progress.status = ThyUploadStatus.done;<br>                uploadFile.progress.percentage = <span class="hljs-number">100</span>;<br>                uploadFile.progress.speed = speedAverage;<br>                uploadFile.progress.speedHuman = <span class="hljs-string">`<span class="hljs-subst">$&#123;humanizeBytes(speed, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>)&#125;</span>/s`</span>;<br>                uploadFile.progress.estimatedTime = estimatedTime;<br>                uploadFile.progress.estimatedTimeHuman = <span class="hljs-built_in">this</span>.secondsToHuman(estimatedTime || <span class="hljs-number">0</span>);<br><br>                uploadFile.responseStatus = xhr.status;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    uploadFile.response = <span class="hljs-built_in">JSON</span>.parse(xhr.response);<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    uploadFile.response = xhr.response;<br>                &#125;<br><br>                <span class="hljs-comment">// file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());</span><br><br>                observer.next(&#123; <span class="hljs-attr">status</span>: ThyUploadStatus.done, <span class="hljs-attr">uploadFile</span>: uploadFile &#125;);<br><br>                observer.complete();<br>            &#125;<br>        &#125;;<br><br>        xhr.upload.addEventListener(<span class="hljs-string">&#x27;progress&#x27;</span>, onProgress, <span class="hljs-literal">false</span>);<br>        xhr.upload.addEventListener(<span class="hljs-string">&#x27;error&#x27;</span>, onError);<br>        <span class="hljs-comment">// When using the [timeout attribute](https://xhr.spec.whatwg.org/#the-timeout-attribute) and an XHR</span><br>        <span class="hljs-comment">// request times out, browsers trigger the `timeout` event (and executes the XHR&#x27;s `ontimeout`</span><br>        <span class="hljs-comment">// callback). Additionally, Safari 9 handles timed-out requests in the same way, even if no `timeout`</span><br>        <span class="hljs-comment">// has been explicitly set on the XHR.</span><br>        xhr.upload.addEventListener(<span class="hljs-string">&#x27;timeout&#x27;</span>, onError);<br>        xhr.addEventListener(<span class="hljs-string">&#x27;timeout&#x27;</span>, onError);<br>        xhr.addEventListener(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, onReadyStateChange);<br><br>        xhr.open(uploadFile.method, uploadFile.url, <span class="hljs-literal">true</span>);<br>        xhr.withCredentials = uploadFile.withCredentials ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();<br><br>            <span class="hljs-built_in">Object</span>.keys(uploadFile.data || &#123;&#125;).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> formData.append(key, uploadFile.data[key]));<br>            <span class="hljs-built_in">Object</span>.keys(uploadFile.headers || &#123;&#125;).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> xhr.setRequestHeader(key, uploadFile.headers[key]));<br><br>            formData.append(uploadFile.fileField || <span class="hljs-string">&#x27;file&#x27;</span>, uploadFile.nativeFile, uploadFile.fileName);<br><br>            observer.next(&#123; <span class="hljs-attr">status</span>: ThyUploadStatus.started, <span class="hljs-attr">uploadFile</span>: uploadFile &#125;);<br>            xhr.send(formData);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            observer.error(error);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            xhr,<br>            <span class="hljs-attr">cleanup</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                xhr.upload.removeEventListener(<span class="hljs-string">&#x27;progress&#x27;</span>, onProgress);<br>                xhr.upload.removeEventListener(<span class="hljs-string">&#x27;error&#x27;</span>, onError);<br>                xhr.upload.removeEventListener(<span class="hljs-string">&#x27;timeout&#x27;</span>, onError);<br>                xhr.removeEventListener(<span class="hljs-string">&#x27;timeout&#x27;</span>, onError);<br>                xhr.removeEventListener(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, onReadyStateChange);<br>            &#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ensure<span class="hljs-constructor">FileName(<span class="hljs-params">uploadFile</span>: ThyUploadFile)</span> &#123;<br>    uploadFile.fileName = uploadFile.fileName<span class="hljs-operator"> || </span>uploadFile.nativeFile.name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析">分析</h3><p>代码看着挺长的，但是其逻辑不难，核心点就两个部分。</p><ol><li><p>upload 方法返回了一个 ThyUploadResponse 类型的 Observable 可观察对象， 其构造函数传入一个 observer（观察者/订阅者），return了一个 unsubscribe 函数，用于取消订阅。</p></li><li><p>重点是创建 Observable 时的回调函数，它里面调用了最关键的 uploadByXhr(observer, uploadFile) 方法，其中把观察者 observer 和 文件详情对象 uploadFile 作为参数传了进去。</p><ul><li><p>注入 XhrFactory 服务，调用 build() 函数获取 XMLHttpRequest 对象</p></li><li><p>定义了 progress、error、readystatechange 事件的回调函数</p></li><li><p>调用 open() 实例化方法来创建一个新的请求</p></li><li><p>调用 send() 实例化方法来发送 HTTP 请求，数据体为 FormData 类型</p></li><li><p>最后 return 出去一个包含 XMLHttpRequest 对象和一个用于取消监听的函数</p></li></ul></li><li><p>最后看一下 upload() 函数中 return 的 unsubscribe 函数中都干了些啥？</p><ul><li><p>调用 cleanup() 函数，用于取消各种 upload 时的监听事件</p></li><li><p>当 xhr.readyState !== xhr.DONE 时，执行 xhr.abort() 函数，abort() 函数的作用是取消 http 请求，用作取消上传。</p></li></ul></li><li><p>progress 事件会在请求接收到数据的时候被周期性触发，ProgressEvent.loaded 只读属性是一个整数，表示底层的进程已经执行的工作量，可以使用该属性和 ProgressEvent.total 计算完成工作的比率。</p></li><li><p>由于 progress 事件会周期性的传输数据，所以调用 upload 函数的时候也会周期性的接受到数据，返回值中已经有计算好的各种数值，就可以拿来直接展示了。</p></li></ol><h3 id="与上传有关的类">与上传有关的类</h3><p>上述分析中简单的涉及了一些类和函数，下面来系统的看一下。</p><h4 id="XMLHttpRequest">XMLHttpRequest</h4><p>其实例方法、事件比较多，可参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">使用XMLHttpRequest</a></p><h4 id="ProgressEvent">ProgressEvent</h4><p>ProgressEvent 接口是测量如 HTTP 请求（一个XMLHttpRequest，或者一个 img，audio，video，style 或 link 等底层资源的加载）等底层流程进度的事件。</p><h5 id="实例属性">实例属性</h5><p><em>lengthComputable</em><br>ProgressEvent.lengthComputable 只读属性是一个布尔Boolean (en-US) 标志，表示ProgressEvent 所关联的资源是否具有可以计算的长度。</p><p><em>loaded</em><br>ProgressEvent.loaded 只读属性是一个整数，表示底层的进程已经执行的工作量。</p><p><em>total</em><br>是一个无符号 64 位整数值，表明正在处理或者传输的数据的总大小。</p><h4 id="FormData">FormData</h4><p>FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 “multipart/form-data”，它会使用和表单一样的格式。</p><h5 id="实例方法">实例方法</h5><p><em>append()</em><br>添加一个新值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键。</p><p><em>set()</em><br>对 FormData 对象里的某个 key 设置一个新的值，如果该 key 不存在，则添加。</p><p>set() 和 FormData.append 不同之处在于：如果某个 key 已经存在，set() 会直接覆盖所有该 key 对应的值，而 FormData.append 则是在该 key 的最后位置再追加一个值。</p><h3 id="功能优化">功能优化</h3><p>通常涉及到文件上传功能时，当离开页面时如果还有正在上传的文件，则需要给用户友好的提示。如：</p><p><img src="/img/fileupload/fileupload_1.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">initBeforeunload</span>(<span class="hljs-params"></span>)</span> &#123;<br>    fromEvent(<span class="hljs-built_in">window</span>,<span class="hljs-string">&#x27;beforeunload&#x27;</span>)<br>    .pipe(takeUntil(<span class="hljs-built_in">this</span>.$unSubscribe))<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> queues =  <span class="hljs-built_in">Object</span>.values(<span class="hljs-built_in">this</span>.queues);<br>        <span class="hljs-keyword">const</span> isUploading = queues.find(<span class="hljs-function"><span class="hljs-params">queue</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> queue?.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> item?.result?.status === ThyUploadStatus.started || item?.result?.status === ThyUploadStatus.uploading;<br>            &#125;);<br>        &#125;)<br>        <span class="hljs-keyword">if</span> (isUploading) &#123;<br>            e = e || <span class="hljs-built_in">window</span>.event;<br>            <span class="hljs-keyword">const</span> tips = <span class="hljs-built_in">this</span>.util.translate.instant(<span class="hljs-string">&#x27;validation.BEFOREUNLOAD_CHECK&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (e) &#123;<br>                e.returnValue = <span class="hljs-literal">true</span>;<br>            &#125;<br>            e.preventDefault();<br>            <span class="hljs-keyword">return</span> tips;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.$unSubscribe.next(<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">this</span>.$unSubscribe.complete();<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Window-beforeunload-event">Window: beforeunload event</h4><p>当浏览器窗口关闭或者刷新时，会触发 beforeunload 事件。当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。</p><p><strong>注意</strong></p><ol><li><p>根据规范，要显示确认对话框，事件处理程序需要在事件上调用preventDefault()，不加不生效。</p></li><li><p>并非所有浏览器都支持此方法，而有些浏览器需要事件处理程序实现两个遗留方法中的一个作为代替，所以最好做一下浏览器的兼容：<br>1）将字符串分配给事件的returnValue属性<br>2）从事件处理程序返回一个字符串。</p></li><li><p>某些浏览器过去在确认对话框中显示返回的字符串，从而使事件处理程序能够向用户显示自定义消息。但是，此方法已被弃用，并且在大多数浏览器中不再支持。</p></li><li><p>在 beforeunload 事件中，window 对象的 alert、confirm等方法无效。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常开发中那些不常用的css属性</title>
    <link href="/posts/747db437/"/>
    <url>/posts/747db437/</url>
    
    <content type="html"><![CDATA[<p>由于 css 属性的繁多和难学，本篇文章旨在记录平常开发中遇到的那些 css 属性，会长期更新记录。</p><p>【注】点击 css 的属性名称可以跳转到 MDN 链接，可查看更详细的用法。</p><div class="note note-success">            <ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events">pointer-events</a></li></ol>          </div><p>pointer-events CSS 属性设置在什么情况下(如果有的话)一个特定的图形元素可以成为指针事件的目标。</p><p>通常和 opacity 属性和 cursor 属性搭配使用。</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">pointer-events</span>: none;<br><span class="hljs-attribute">cursor</span>: not-allowed;<br><span class="hljs-attribute">opacity</span>: .<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/normal-css/point-events-1.png" alt=""></p><div class="note note-success">            <ol start="2"><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter">filter</a></li></ol>          </div><p>css 的 filter 属性可以用来实现网页的「默哀模式」,让整个网站变灰色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">80%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <ol start="2"><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter">border-collapse</a></li></ol>          </div><p>设置 &lt; table &gt; 中的单元格是否具有共享边框或单独的边框。</p><p>border-collapse = separate  |  collapse</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">collapse</span>: <span class="hljs-built_in">collapse</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/normal-css/collapse.png" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: separate;<br></code></pre></td></tr></table></figure><p><img src="/img/normal-css/separate.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript Notifications API</title>
    <link href="/posts/5a30c4fd/"/>
    <url>/posts/5a30c4fd/</url>
    
    <content type="html"><![CDATA[<p>Notifications API 允许网页或应用程序发送通知，这些通知在系统级显示在网页之外; 这使得网页应用程序可以向用户发送信息，即使应用程序处于空闲状态或在后台，一般搭配 websocket 使用。</p><div class="note note-info">            <p>安全上下文: 此特性仅在安全上下文(HTTPS)中可用，在部分或所有支持的浏览器中都可用。</p>          </div><p>需要注意的是此 API 只有在 https 的网页中才有效果，但是经过我的测试发现在 Firefox 浏览器中貌似本地也可以调试，但是 Chrome本地开发环境下确实不行。那么如果非要想在 Chrome 浏览器的本地开发环境下调试应该怎么办呢？我查了好久也终于找到了相应的解决方案：</p><p><a href="https://blog.csdn.net/qq_25231683/article/details/127447769">在 HTTP 网站中开启 Notification API</a></p><h3 id="请求权限">请求权限</h3><p>在应用可以发送通知之前，用户必须授予应用有权这么做。这是一个常见的要求，当一个 API 至少一次试图与 web 页外部进行交互时，用户不得不专门授予该应用程序有权限提出通知，从而让用户控制允许哪些应用程序或网站显示通知。</p><p>权限状态有以下三种：</p><ul><li><p>default：用户还未被询问是否授权，所以通知不会被显示。参看 获得权限 以了解如何请求显示通知的权限。</p></li><li><p>granted：表示之前已经询问过用户，并且用户已经授予了显示通知的权限。</p></li><li><p>denied：用户已经明确的拒绝了显示通知的权限。</p></li></ul><p>如果权限尚未被授予，那么应用不得不通过 Notification.requestPermission() 方法让用户进行选择。这个方法接受一个回调函数，一旦用户回应了显示通知的请求，将会调用这个函数。</p><p>通常你应在你的应用首次初始化的时候请求显示通知的权限：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs kotlin">checkPermission(onSuccess?: Function, onError?: Function, onThen?: Function) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.permissionLevel !== <span class="hljs-string">&#x27;granted&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isSupported) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Notification.requestPermission(result =&gt; &#123;<br>                <span class="hljs-keyword">if</span> (result === <span class="hljs-string">&#x27;granted&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">this</span>.permissionLevel = <span class="hljs-string">&#x27;granted&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (onSuccess) &#123;<br>                        onSuccess();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result === <span class="hljs-string">&#x27;denied&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">this</span>.permissionLevel = <span class="hljs-string">&#x27;denied&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (onError) &#123;<br>                        onError();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">this</span>.isSetPermission = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.permissionLevel = <span class="hljs-string">&#x27;granted&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (onSuccess) &#123;<br>                onSuccess();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.isSetPermission = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (onThen) &#123;<br>            onThen();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="创建通知">创建通知</h3><p>创建通知很简单，只需要用 Notification 构造方法。这个构造函数需要一个用来显示在通知内的标题以及一些用来增强通知的选项，例如 icon 或文本 body。</p><p>一旦通知被创建出来，它会立即被显示出来。为了跟踪通知当前的状态，在 Notification 实例层面上会有 4 个事件被触发：</p><ul><li>show：当通知被显示给用户时触发。</li><li>click：当用户点击通知时触发。</li><li>close：当通知被关闭时触发。</li><li>error：当通知发生错误的时候触发。这通常是因为通知由于某些原因而无法显示。</li></ul><p>这些事件可以通过事件处理跟踪 onshow、onclick、onclose 和 onerror。因为 Notification 同样继承自 EventTarget，因此可以对它调用 addEventListener() 方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params">option: &#123; title?: <span class="hljs-built_in">string</span>; body?: <span class="hljs-built_in">string</span>; icon?: <span class="hljs-built_in">string</span>, click?: <span class="hljs-built_in">Function</span> &#125;</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isSupported) &#123;<br>            <span class="hljs-keyword">const</span> notifyOption = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, <span class="hljs-built_in">this</span>.configOptions, option);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.permissionLevel === <span class="hljs-string">&#x27;granted&#x27;</span>) &#123;<br>                <span class="hljs-keyword">const</span> notification = <span class="hljs-keyword">new</span> Notification(notifyOption.title, notifyOption);<br>                <span class="hljs-keyword">if</span> (option.click) &#123;<br>                    notification.onclick = <span class="hljs-function">() =&gt;</span> &#123;<br>                        option.click();<br>                        notification.close();<br>                    &#125;;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Notification.requestPermission(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (result === <span class="hljs-string">&#x27;granted&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">const</span> notification = <span class="hljs-keyword">new</span> Notification(notifyOption.title, notifyOption);<br>                        <span class="hljs-keyword">if</span> (option.click) &#123;<br>                            notification.onclick = <span class="hljs-function">() =&gt;</span> &#123;<br>                                option.click();<br>                                notification.close();<br>                            &#125;;<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="关闭通知">关闭通知</h3><p>可以使用 close ()删除与用户不再相关的通知。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js原生api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Intersection Observer API</title>
    <link href="/posts/4e1dac9a/"/>
    <url>/posts/4e1dac9a/</url>
    
    <content type="html"><![CDATA[<p>在我们公司的产品中，发现了一个新上线的有意思的交互效果，原本我以为这种交互是借助了 positon: sticky 定位实现，但是细细观察后发现并不是，于是翻看源码研究了一下，并于此学到了一个新的有意思的 API: Intersection Observer。</p><span id="more"></span><p>先看一下产品的交互效果：当滚动条向下滚动时，在内容的标题即将消失的时候，模块框顶部的标题内容就换成了内容的标题。</p><p><img src="/img/intersection/1.gif" alt=""></p><p>先说一下实现思路吧：实现此交互的关键点就是在于怎么优雅的判断出内容的标题的可见性？解决了这个问题以后，接下来就是在内容的标题消失或者出现的节点，添加上相应的 css 过渡属性（transition）样式就可以了。</p><h3 id="Intersection-observer-概念和用法">Intersection observer 概念和用法</h3><p>Intersection Observer API 提供了一种异步观察目标元素与祖先元素或顶级文档视口交集中的变化的方法。</p><p>Intersection Observer API 允许您配置一个回调函数，在以下情况发生时调用该函数:</p><ul><li><p>每当目标 (target) 元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根 (root)。</p></li><li><p>Observer 第一次监听目标元素的时候</p></li></ul><p>目标 (target) 元素与根 (root) 元素之间的交叉度是交叉比 (intersection ratio)。这是目标 (target) 元素相对于根 (root) 的交集百分比的表示，它的取值在 0.0 和 1.0 之间。</p><p>用法也是非常简单，分为以下步骤：</p><ol><li>创建一个 intersection observer</li></ol><p>创建一个 IntersectionObserver 对象，并传入相应参数和回调用函数，该回调函数将会在目标 (target) 元素和根 (root) 元素的交集大小超过阈值 (threshold) 规定的大小时候被执行。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> options = &#123;<br>  root: document.query<span class="hljs-constructor">Selector(&#x27;#<span class="hljs-params">scrollArea</span>&#x27;)</span>,<br>  rootMargin: &#x27;<span class="hljs-number">0</span>px&#x27;,<br>  threshold: <span class="hljs-number">1.0</span><br>&#125;<br><br><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">IntersectionObserver(<span class="hljs-params">callback</span>, <span class="hljs-params">options</span>)</span>;<br></code></pre></td></tr></table></figure><p>阈值为 1.0 意味着目标元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。</p><ol start="2"><li>Intersection observer options</li></ol><p>传递到 IntersectionObserver() 构造函数的 options 对象，允许您控制观察者的回调函数的被调用时的环境。它有以下字段：</p><div class="note note-success">            <p>info</p>          </div><p>指定根 (root) 元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为null，则默认为浏览器视窗。</p><div class="note note-success">            <p>rootMargin</p>          </div><p>根 (root) 元素的外边距。类似于 CSS 中的 margin 属性，比如 “10px 20px 30px 40px” (top、right、bottom、left)。如果有指定 root 参数，则 rootMargin 也可以使用百分比来取值。该属性值是用作 root 元素和 target 发生交集时候的计算交集的区域范围，使用该属性可以控制 root 元素每一边的收缩或者扩张。默认值为四个边距全是 0。</p><div class="note note-success">            <p>threshold</p>          </div><p>可以是单一的 number 也可以是 number 数组，target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。如果你只是想要探测当 target 元素的在 root 元素中的可见性超过 50% 的时候，你可以指定该属性值为 0.5。如果你想要 target 元素在 root 元素的可见程度每多 25% 就执行一次回调，那么你可以指定一个数组 [0, 0.25, 0.5, 0.75, 1]。默认值是 0 (意味着只要有一个 target 像素出现在 root 元素中，回调函数将会被执行)。该值为 1.0 含义是当 target 完全出现在 root 元素中时候 回调才会被执行。</p><ol start="3"><li>Targeting an element to be observed</li></ol><p>创建一个 observer 后需要给定一个目标元素进行观察。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">let <span class="hljs-keyword">target</span> = document.querySelector(<span class="hljs-string">&#x27;#listItem&#x27;</span>);<br>observer.observe(<span class="hljs-keyword">target</span>);<br></code></pre></td></tr></table></figure><h3 id="实战Demo">实战Demo</h3><p>大概了解了该 API 的语法以后，尝试写一个简单的 demo 还原一下公司产品的那种交互效果。</p><p>html</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#x27;fixed&#x27;: isFixed&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title1&quot;</span>&gt;</span>目标元素可见<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title2&quot;</span>&gt;</span>目标元素消失啦<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">wraper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wraper&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> #<span class="hljs-attr">box</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>scss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>    <span class="hljs-attribute">position</span>: relative;<br><br>    <span class="hljs-selector-tag">header</span> &#123;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br>      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#aaa</span>;<br>      <span class="hljs-attribute">display</span>: flex;<br>      <span class="hljs-attribute">align-items</span>: center;<br><br>      <span class="hljs-selector-class">.title1</span> &#123;<br>        <span class="hljs-attribute">visibility</span>: visible;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0px</span>;<br>        <span class="hljs-attribute">transition</span>: <span class="hljs-number">400ms</span> ease-out;<br>        <span class="hljs-attribute">transition-property</span>: margin-top, opacity;<br>        <span class="hljs-attribute">position</span>: inherit;<br>        <span class="hljs-attribute">overflow</span>: hidden;<br>      &#125;<br><br>      <span class="hljs-selector-class">.title2</span> &#123;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">visibility</span>: hidden;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">32px</span>;<br>        <span class="hljs-attribute">transition</span>: <span class="hljs-number">400ms</span> ease-out;<br>        <span class="hljs-attribute">transition-property</span>: margin-top, opacity;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-selector-class">.wraper</span> &#123;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;<br>      <span class="hljs-attribute">overflow</span>: auto;<br>      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br><br>      <span class="hljs-selector-class">.box</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">background-color</span>: red;<br>      &#125;<br><br>      <span class="hljs-selector-class">.content</span> &#123;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">1100px</span>;<br>      &#125;<br>    &#125;<br><br>    &amp;<span class="hljs-selector-class">.fixed</span> &#123;<br>      <span class="hljs-selector-tag">header</span> &#123;<br>        <span class="hljs-selector-class">.title1</span> &#123;<br>          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>          <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">32px</span>;<br>          <span class="hljs-attribute">position</span>: absolute;<br>          <span class="hljs-attribute">pointer-events</span>: none;<br>        &#125;<br>  <br>        <span class="hljs-selector-class">.title2</span> &#123;<br>          <span class="hljs-attribute">display</span>: flex;<br>          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>          <span class="hljs-attribute">visibility</span>: visible;<br>          <span class="hljs-attribute">position</span>: inherit;<br>          <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>ts</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ViewChild(<span class="hljs-meta-string">&#x27;wraper&#x27;</span>, &#123; read: ElementRef &#125;)</span> body!: ElementRef;<br><br><span class="hljs-meta">@ViewChild(<span class="hljs-meta-string">&#x27;box&#x27;</span>, &#123; read: ElementRef &#125;)</span> box!: ElementRef;<br><br>isFixed: boolean = <span class="hljs-literal">false</span>;<br><br>ngAfterViewInit(): void &#123;<br>   <span class="hljs-keyword">const</span> options = &#123;<br>     root: <span class="hljs-keyword">this</span>.body.nativeElement,<br>     rootMargin: <span class="hljs-string">&#x27;0px&#x27;</span>,<br>     threshold: <span class="hljs-number">0.2</span>,<br>   &#125;;<br>   <span class="hljs-keyword">const</span> observer = new IntersectionObserver(<span class="hljs-keyword">this</span>.callback, options);<br>   observer.observe(<span class="hljs-keyword">this</span>.box.nativeElement);<br> &#125;<br><br> callback = (<span class="hljs-keyword">data</span>: IntersectionObserverEntry[]) =&gt; &#123;<br>   <span class="hljs-keyword">const</span> intersectionRatio = <span class="hljs-keyword">data</span>[<span class="hljs-number">0</span>]?.intersectionRatio;<br>     <span class="hljs-keyword">if</span> (intersectionRatio &lt; <span class="hljs-number">0.2</span>) &#123;<br>       <span class="hljs-keyword">this</span>.isFixed = <span class="hljs-literal">true</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">this</span>.isFixed = <span class="hljs-literal">false</span>;<br>     &#125;<br> &#125;;<br></code></pre></td></tr></table></figure><p>完结撒花🎉，最后看一下效果：</p><p><img src="/img/intersection/2.gif" alt=""></p><h3 id="总结">总结</h3><p>这里只是实现了个简单的交互效果，其实 Intersection observer API 的作用远不止于此，比如 还可以用来实现图片的懒加载、内容无限滚动等，感兴趣的可以去查看更详细的用法：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#intersection_observer_concepts_and_usage">MDN-Intersection Observer API</a></p><p>最后总结一下用到的知识点：</p><ol><li>Intersection observer API</li><li>利用 css 的 transition、transition-property 属性</li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js原生api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular中的开发技巧</title>
    <link href="/posts/61885c8d/"/>
    <url>/posts/61885c8d/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面-👣">写在前面 👣</h3><p>angular是一个非常优秀的前端框架，但是各种语法和api也是相对较多，掌握一些开发技巧可以使我们写的代码看起来更优雅，我接触angular开发三年有余，加入我们worktile团队也有一段时间了，不管是通过自己学习还是参考研究前辈写的代码，学到了很多新的知识，正好借此机会来一波总结。</p><span id="more"></span><h3 id="工具篇-🛠️">工具篇 🛠️</h3><p>俗话说工欲善其事，必先利其器。先推荐几个我装机必备的软件和插件。</p><ol><li>utools 软件</li></ol><p>提高生产力的工具，轻量、安全、简洁、无广告。</p><ol start="2"><li>FeHelper 浏览器插件</li></ol><p>前端助手</p><ol start="3"><li>沙拉查词</li></ol><p>Saladict 沙拉查词是一款专业划词翻译扩展，为交叉阅读而生。大量权威词典涵盖中英日韩法德西语。</p><h3 id="js-ts-篇-🎃">js/ts 篇 🎃</h3><ol><li>求数组中的总和、最大最小值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li>求和</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">array.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =&gt;</span> pre + cur);<br></code></pre></td></tr></table></figure><ul><li>求最大值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">array.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =&gt;</span> pre &gt; cur ? pre : cur);<br></code></pre></td></tr></table></figure><ul><li>求最小值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">array.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =&gt;</span> pre &lt; cur ? pre : cur);<br></code></pre></td></tr></table></figure><ol start="2"><li>过滤出数组中的真值</li></ol><p>参数值为 0 、 -0 、 null 、 false 、 NaN 、 undefined ，或空字符串（ “” ），则该对象具</p><p>有的初始值为 false</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">0</span>,-<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">NaN</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br>array.filter(<span class="hljs-built_in">Boolean</span>);<br><br><span class="hljs-comment">// Boolean不仅是一个boolean类型的包装器，也可以作为转换函数使用，等同于双重非运算符!!</span><br><span class="hljs-comment">// 上行代码等同于：</span><br><span class="hljs-comment">// array.filter(item =&gt; Boolean(item)); </span><br><br><span class="hljs-comment">// 输出：[1, 2, 3]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>去除数组中重复值</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> array = [a,b,c,d,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,a,e,f,<span class="hljs-number">1</span>];<br><br>array.filter(<span class="hljs-function">(<span class="hljs-params">item,idx</span>) =&gt;</span> array.indexOf(item) === idx);<br><br>array = [...new <span class="hljs-built_in">Set</span>(array)]<br></code></pre></td></tr></table></figure><ol start="4"><li>三元运算符和空合并运算符(??)</li></ol><p>三元运算符大家经常用，但是有时候或许空合并运算符才是最佳选择。</p><p>空合并运算符 (??) 是一个逻辑运算符，当其左侧操作数为空或未定义时返回其右侧操作数，否则返回其左侧操作数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> item: <span class="hljs-built_in">any</span> = helpers.find(okrObjectiveType, &#123; <span class="hljs-attr">value</span>: value.type &#125;);<br><span class="hljs-keyword">return</span> item ? item.desc : <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-comment">// 等同于：</span><br><span class="hljs-keyword">return</span> item?.desc ?? <span class="hljs-string">&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="5"><li>展开语法</li></ol><ul><li>合并对象属性不要再用 Object.assign() 属性啦</li></ul><p>展开对象的语法和 Object.assign() 行为一致，执行的都是浅拷贝 (只遍历一层)。但是语法更简短，需要注</p><p>意的是 Object.assign() 函数会触发 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set"> setters </a>，而展开语法则不会。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> user = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kapil Raghuwanshi&#x27;</span>, <br> <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;Male&#x27;</span> <br>&#125;;<br><br><span class="hljs-keyword">const</span> college = &#123; <br> <span class="hljs-attr">primary</span>: <span class="hljs-string">&#x27;Mani Primary School&#x27;</span>, <br> <span class="hljs-attr">secondary</span>: <span class="hljs-string">&#x27;Lass Secondary School&#x27;</span> <br>&#125;;<br><br><span class="hljs-keyword">const</span> summary = &#123;...user,...college&#125;;<br></code></pre></td></tr></table></figure><ul><li>连接多个数组</li></ul><p>没有展开语法的时候，只能组合使用 push , splice , concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法，通过字面量方式，构造新数组会变得更简单、更优雅！</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> parts = [<span class="hljs-string">&#x27;shoulders&#x27;</span>, <span class="hljs-string">&#x27;knees&#x27;</span>];<br><br><span class="hljs-keyword">const</span> lyrics = [<span class="hljs-string">&#x27;head&#x27;</span>, ...parts, <span class="hljs-string">&#x27;and&#x27;</span>, <span class="hljs-string">&#x27;toes&#x27;</span>];<br><br><span class="hljs-comment">// [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]</span><br></code></pre></td></tr></table></figure><ol start="6"><li>可选链</li></ol><p>可选的链接 ?. 如果值在 ? 之前，则停止评估。为 undefined 或 null 并返回。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">thy-avatar</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;styx-body-title-doc-avatar&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">thyShowName</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">      [<span class="hljs-attr">thySize</span>]=<span class="hljs-string">&quot;24&quot;</span></span><br><span class="hljs-tag">      [<span class="hljs-attr">thyName</span>]=<span class="hljs-string">&quot;detailInfo?.created_by?.display_name&quot;</span></span><br><span class="hljs-tag">      [<span class="hljs-attr">thySrc</span>]=<span class="hljs-string">&quot;detailInfo?.created_by?.avatar&quot;</span></span><br><span class="hljs-tag">      [<span class="hljs-attr">thyDisabled</span>]=<span class="hljs-string">&quot;detailInfo?.created_by?.uid | isDisabledMember&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">thy-avatar</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="7"><li>参数默认值</li></ol><p>给函数参数设置默认值有时会很方便。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Pipe</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;taskStateClass&#x27;</span> &#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskStateClassPipe</span> <span class="hljs-title">implements</span> <span class="hljs-title">PipeTransform</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">transform</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-built_in">number</span>, prefix = <span class="hljs-string">&#x27;wtf-&#x27;</span></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">type</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> stateConstantMap = helpers.keyBy(stateConstant, <span class="hljs-string">&#x27;value&#x27;</span>);<br>        <span class="hljs-keyword">const</span> state = stateConstantMap[<span class="hljs-keyword">type</span>];<br>        <span class="hljs-keyword">let</span> className = state ? state.className : <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (prefix) &#123;<br>            className = prefix + className;<br>        &#125;<br>        <span class="hljs-keyword">return</span> className;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>巧妙的使用结构赋值可以避免使用 any 类型</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">onViewFilter</span>(<span class="hljs-params">$event: &#123; config: MissionViewFilterConfigurationInfo; originConfig: MissionViewFilterConfigurationInfo &#125;</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> ($event.config.date_unit !== $event.originConfig.date_unit) &#123;<br>            <span class="hljs-built_in">this</span>.initDateRangeValue($event.config.date_unit);<br>            <span class="hljs-built_in">this</span>.setDateRange();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>padStart方法补0</li></ol><p>getDate()、getMonth() 等api获取日期的值可能只有一位，常见的需求是格式化成两位数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getDate(); <span class="hljs-comment">// 21</span><br><br><span class="hljs-keyword">const</span> month = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getMonth()&#125;</span>`</span>.padStart(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">// 08</span><br></code></pre></td></tr></table></figure><ol start="10"><li>字符串转number类型快捷方法</li></ol><p>一元的 + 号运算符相当于 Number() 方法。</p><p>先来回顾一下 JavaScript 中的原始值都有哪些：</p><p>JavaScript 中的原始值是指数字、字符串、布尔值、null和undefined。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = +<span class="hljs-string">&#x27;3&#x27;</span>; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">+ <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// NaN</span><br> <br>+ <span class="hljs-literal">null</span>; <span class="hljs-comment">// 0</span><br> <br>+ <span class="hljs-literal">true</span>; <span class="hljs-comment">// 1</span><br>+ <span class="hljs-literal">false</span>; <span class="hljs-comment">// 0</span><br> <br>+ <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-comment">// 1</span><br>+ <span class="hljs-string">&#x27;-1&#x27;</span>; <span class="hljs-comment">// -1</span><br>+ <span class="hljs-string">&#x27;a1&#x27;</span>; <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// Object类型的值的转换：</span><br><br>+ <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-comment">// 1663912235982</span><br>+ &#123;&#125;; <span class="hljs-comment">// =&gt; NaN</span><br>+ &#123; <span class="hljs-attr">valueOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125; &#125;; <span class="hljs-comment">// =&gt; 0</span><br>+ &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>    <span class="hljs-attr">valueOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a;<br>    &#125;,<br>    <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Apply the following steps:<br>1.Let primValue be ToPrimitive(input argument, hint Number).<br>2.Return ToNumber(primValue).</p><p>ToPrimitive会调用 [[DefaultValue]]内部方法</p><p>1.Let valueOf be the result of calling the [[Get]] internal method of object O with argument “valueOf”.<br>2.If IsCallable(valueOf) is true then,<br>a.Let val be the result of calling the [[Call]] internal method of valueOf, with O as the this value and an empty argument list.<br>b.If val is a primitive value, return val.</p><p>简单来说就是：如果传入的值是 object 类型的话，会先调用 Object.valueOf() 函数，如果其返回值属于原始值类型，那么就继续调用Number() 函数，否则会去调用 Object.toString() 函数，输入其返回值。</p><h3 id="rxjs篇-🐇">rxjs篇 🐇</h3><ol><li>使用takeUntil取消订阅</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">destroy$: Subject&lt;<span class="hljs-built_in">any</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-built_in">any</span>&gt;();<br><span class="hljs-function"><span class="hljs-title">ngOnInit</span>(<span class="hljs-params"></span>)</span> &#123;<br>  request.pipe(takeUntil(<span class="hljs-built_in">this</span>.destroy$)).subscribe();<br>  request.pipe(takeUntil(<span class="hljs-built_in">this</span>.destroy$)).subscribe();<br>  request.pipe(takeUntil(<span class="hljs-built_in">this</span>.destroy$)).subscribe();<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.destroy$.next(<span class="hljs-literal">null</span>);<br>  <span class="hljs-built_in">this</span>.destroy$.complete();<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：其它批量取消订阅的方式</p><ul><li>SubscriptionLike</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">subscriptions: SubscriptionLike[] = [];<br><span class="hljs-function"><span class="hljs-title">ngOnInit</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.subscriptions.push(request.subscribe(...));<br>  <span class="hljs-built_in">this</span>.subscriptions.push(request.subscribe(...));<br>  <span class="hljs-built_in">this</span>.subscriptions.push(request.subscribe(...));<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.subscriptions.forEach(<br>    <span class="hljs-function">(<span class="hljs-params">subscription</span>) =&gt;</span> subscription.unsubscribe());<br>&#125;<br></code></pre></td></tr></table></figure><p>关于 SubscriptionLike 类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SubscriptionLike <span class="hljs-keyword">extends</span> Unsubscribable &#123;<br>  get closed: <span class="hljs-built_in">boolean</span><br>  unsubscribe(): <span class="hljs-built_in">void</span><br><br>  <span class="hljs-comment">// inherited from index/Unsubscribable</span><br>  unsubscribe(): <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实现类：</p><p>Subject、BehaviorSubject、ReplySubject、AsyncSubject、Subscription、Subscriber</p><ul><li>Subscription</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">subscriptions: Subscription = <span class="hljs-keyword">new</span> Subscription();<br><span class="hljs-function"><span class="hljs-title">ngOnInit</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.subscriptions.add(request.subscribe(...));<br>  <span class="hljs-built_in">this</span>.subscriptions.add(request.subscribe(...));<br>  <span class="hljs-built_in">this</span>.subscriptions.add(request.subscribe(...));<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.subscriptions.unsubscribe();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>forkJoin连接多个请求</li></ol><p>当有一组 observables，但你只关心每个 observable 最后发出的值时，此操作符是最适合的。此操作符的一个常见用例是在页面加载(或其他事件)时你希望发起多个请求，并在所有请求都响应后再采取行动。</p><ol start="3"><li>distinctUntilChanged去除重复数据</li></ol><p>只有当当前值与之前最后一个值不同时才会发出。distinctUntilChanged 默认使用 === 进行比较</p><ol start="4"><li>finalize/finally</li></ol><p>当Observable完成或者报错时调用。</p><ol start="5"><li>switchMap</li></ol><p>当前一个订阅未完成时，又发出新的订阅，则会取消之前订阅。</p><p>Demo------Typehead 搜索:</p><p>类型头搜索是一种通过文本逐步搜索和过滤的方法。它有时也被称为自动完成，增量搜索，搜索作为你的类型，内联搜索，即时搜索和字轮。</p><p><a href="https://www.how2js.site/2022/08/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Rxjs%E7%9A%84Operators%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">关于类型头搜索优化的demo之前文章有专门写过</a></p><p><a href="https://www.how2js.site/2022/09/01/%E9%AB%98%E9%98%B6-RxJs-%E6%98%A0%E5%B0%84%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%BC%E5%90%88%E6%8C%87%E5%8D%97%EF%BC%9AswitchMap%E3%80%81mergeMap%E3%80%81concatMap%EF%BC%88%E5%92%8C-excludeMap%EF%BC%89%E3%80%90%E8%AF%91%E3%80%91/#RxJs-switchMap-%E8%BF%90%E7%AE%97%E7%AC%A6">扩展：concatMap、mergeMap、switchMap和exhaustMap的使用区别和使用场景</a></p><h3 id="Angular语法篇-👼">Angular语法篇 👼</h3><ol><li>合理使用 ngZone  runOutsideAngular 来提升应用性能 我们知道Angular可以自动处理变化检测，这是因为它使用了  zone.js ，简单的来说， zone.js 就是通过打补丁的方式来拦截浏览器的事件，然后进行变化检测，但是变化检测是极其消耗资源的，如果绑定了大量的事件，那么就会造成性能问题，所以我们可以使用  runOutsideAngular 来减少不必要的变化检测。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">this</span>.ngZone.runOutsideAngular(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-built_in">this</span>.renderer.listen(<span class="hljs-built_in">this</span>.elementRef.nativeElement, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> keyCode = event.which || event.keyCode;<br>         <span class="hljs-keyword">if</span> (keyCode === keycodes.ENTER) &#123;<br>              event.preventDefault();<br>              <span class="hljs-built_in">this</span>.ngZone.run(<span class="hljs-function">() =&gt;</span> &#123;<br>                  <span class="hljs-built_in">this</span>.thyEnter.emit(event);<br>              &#125;);<br>         &#125;<br>   &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>@ViewChild 读取指定类型的实例</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> #<span class="hljs-attr">input</span> <span class="hljs-attr">thyInput</span>  [<span class="hljs-attr">thyAutofocus</span>]=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>上面这行代码有三个实例 ElementRef 、 ThyInputComponent 、 ThyAutoFocusDirective ，在某些情况下如果我们要获取指定类型的实例应该怎么做呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">&#x27;input&#x27;</span>, &#123; <span class="hljs-attr">read</span>:ThyInputComponent &#125;)  inputComponent : ThyInputComponent ;<br></code></pre></td></tr></table></figure><ol start="3"><li>动态绑定的样式或者类名如果只有一个时可以简写</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">thy-list-item</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let item of context&quot;</span> [<span class="hljs-attr">class.active</span>]=<span class="hljs-string">&quot;item.isActive&quot;</span></span><br><span class="hljs-tag">    [<span class="hljs-attr">innerHTML</span>]=<span class="hljs-string">&quot;item.elementRef.nativeElement.innerHTML | bypassSecurityTrustHtml&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">thy-list-item</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="其它-🍢">其它 🍢</h3><ol><li>如何浏览器中调试元素的 hover 样式</li></ol><p><img src="/img/angularTips/css-debugger.jpeg" alt=""></p><ol start="2"><li>使用 git 命令的 git cherry-pick 把一个分支的部分commit应用到其他的分支上。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick commitHash<br><br>// 转移多个提交<br><br>git cherry-pick hashA hashB<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rxjs</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高阶 RxJs 映射运算符综合指南：switchMap、mergeMap、concatMap（和 excludeMap）【译】</title>
    <link href="/posts/3fb32397/"/>
    <url>/posts/3fb32397/</url>
    
    <content type="html"><![CDATA[<p><strong><a href="https://blog.angular-university.io/rxjs-higher-order-mapping/">原文: Comprehensive Guide to Higher-Order RxJs Mapping Operators: switchMap, mergeMap, concatMap (and exhaustMap)</a></strong></p><p>我们每天发现的一些最常用的 RxJs 操作符是 RxJs 高阶映射操作符：switchMap、mergeMap、concatMap 和 exhaustMap。</p><span id="more"></span><p>例如，我们程序中的大多数网络调用都将使用这些运算符之一来完成，因此熟悉它们对于编写几乎任何响应式程序都是必不可少的。</p><p>知道在给定情况下使用哪个运算符（以及为什么）可能会有点令人困惑，我们经常想知道这些运算符是如何真正工作的以及为什么它们被这样命名。</p><p>这些操作符看起来似乎无关，但我们真的很想一口气学完它们，因为选择错误的操作符可能会意外地导致我们的程序出现一些微妙的问题。</p><h2 id="为什么映射操作符有点混乱？">为什么映射操作符有点混乱？</h2><p>这是有原因的：为了理解这些操作符，我们首先需要了解每个操作符内部使用的 Observable 组合策略。</p><p>与其试图理解 switchMap 本身，不如先了解什么是 Observable 切换；我们需要先学习 Observable 连接等，而不是直接进入 concatMap。</p><p>这就是我们将在这篇文章中所做的，我们将按逻辑顺序学习 concat、merge、switch 和exhaust策略及其对应的映射运算符：concatMap、mergeMap、switchMap 和 exhaustMap。</p><p>我们将结合弹珠图和一些实际示例（包括运行代码）来解释这些概念。</p><p>最后，您将确切地知道这些映射运算符中的每一个是如何工作的，何时使用它们，为什么使用它们，以及它们命名的原因。</p><h2 id="目录">目录</h2><p>在这篇文章中，我们将讨论以下主题:</p><ul><li>映射运算符</li><li>什么是高阶可观测映射</li><li>可观察到的连锁反应</li><li>RxJs concatMap 操作符</li><li>可观察到的合并</li><li>RxJs mergeMap 运算符</li><li>可观察到的切换</li><li>RxJs switchMap 运算符</li><li>Exhaust 策略</li><li>RxJs exhaust 运算符</li><li>如何选择正确的映射操作符？</li><li>运行 GitHub repo (包含代码示例)</li><li>总结</li></ul><p>请注意，这篇文章是我们正在进行的 <a href="'https://blog.angular-university.io/tag/rxjs/'">RxJs 系列</a>的一部分。因此，闲话少说，让我们开始我们的 RxJs 映射运算符深潜！</p><h2 id="Rxjs映射运算符">Rxjs映射运算符</h2><p>让我们从头开始，介绍一下这些映射运算符的一般作用。</p><p>正如操作符的名称所暗示的那样，它们正在执行某种映射: 但究竟映射的是什么呢？首先让我们看一下 RxJs map 操作符的弹珠图:</p><p><img src="/img/rxjsMap/01-rxjs-map.png" alt=""></p><p>使用 map 操作符，我们可以获取一个输入流(值为1、2、3) ，并从中创建一个派生的映射输出流(值为10、20、30)。</p><p>底部的输出流的值是通过获取输入流的值并应用它们得到的一个函数: 这个函数只是将这些值乘以10。</p><p>因此，映射运算符完全是关于映射输入可观测值的。下面是我们如何使用它来处理 HTTP 请求的一个例子:</p><figure class="highlight livescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> http$ : Observable&lt;Course[]&gt; = <span class="hljs-built_in">this</span>.http.get(<span class="hljs-string">&#x27;/api/courses&#x27;</span>);<br><br>http$<br>    .pipe(<br>        tap(() =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;HTTP request executed&#x27;</span>)),<br>        <span class="hljs-keyword">map</span>(res =&gt; <span class="hljs-built_in">Object</span>.values(res[<span class="hljs-string">&#x27;payload&#x27;</span>]))<br>    )<br>    .subscribe(<br>        courses =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;courses&quot;</span>, courses)<br>    );<br><br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个可观察的 HTTP 来进行后端调用，并且我们订阅了它。可观察对象将发出后端 HTTP 响应的值，这是一个 JSON 对象。</p><p>在这种情况下，HTTP 响应将数据包装在一个有效负载属性中，因此为了获取数据，我们应用了 RxJs 映射操作符。然后映射函数将映射 JSON 响应有效负载并提取有效负载属性的值。</p><p>现在我们已经回顾了基本映射是如何工作的，现在让我们讨论一下高阶映射。</p><h2 id="什么是高阶可观测映射？">什么是高阶可观测映射？</h2><p>在高阶映射中，我们不是将类似1的普通值映射到类似10的另一个值，而是将一个值映射到一个可观察对象！</p><p>结果是一个高阶的 Observable。它只是一个Observable，和其他的一样，但它的值本身也是 Observable，我们可以分别订阅。</p><p>这听起来可能有点牵强，但实际上，这种类型的映射一直在发生。让我们给出这种映射的一个实际例子。举个例子，我们有一个响应式表单，它通过一个Observable 随时间发出有效的表单值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component(&#123;</span><br><span class="hljs-meta">    selector: <span class="hljs-meta-string">&#x27;course-dialog&#x27;</span>,</span><br><span class="hljs-meta">    templateUrl: <span class="hljs-meta-string">&#x27;./course-dialog.component.html&#x27;</span></span><br><span class="hljs-meta">&#125;)</span><br>export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseDialogComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">AfterViewInit</span> </span>&#123;<br><br>    form: FormGroup;<br>    course:Course;<br><br>    <span class="hljs-meta">@ViewChild(<span class="hljs-meta-string">&#x27;saveButton&#x27;</span>)</span> saveButton: ElementRef;<br><br>    <span class="hljs-keyword">constructor</span>(<br>        <span class="hljs-keyword">private</span> fb: FormBuilder,<br>        <span class="hljs-keyword">private</span> dialogRef: MatDialogRef&lt;CourseDialogComponent&gt;,<br>        <span class="hljs-meta">@Inject(MAT_DIALOG_DATA)</span> course:Course) &#123;<br><br>        <span class="hljs-keyword">this</span>.course = course;<br><br>        <span class="hljs-keyword">this</span>.form = fb.group(&#123;<br>            description: [course.description, <br>                          Validators.required],<br>            category: [course.category, Validators.required],<br>            releasedAt: [moment(), Validators.required],<br>            longDescription: [course.longDescription,<br>                              Validators.required]<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Reactive Form 提供了一个可观察的对象 this.Form.valueChanges，它在用户与表单交互时发出最新的表单值。这将是我们可观察到的源头。</p><p>我们想要做的是在这些值随着时间的推移发出时至少保存其中的一些值，以实现表单草案的预保存特性。这样，当用户填写表单时，数据将逐步保存，从而避免由于意外重新加载而丢失整个表单数据。</p><h2 id="为什么是高阶可观察对象？">为什么是高阶可观察对象？</h2><p>为了实现表单草案保存功能，我们需要获取表单值，然后创建第二个可观察的 HTTP 对象来执行后端保存，然后订阅它。</p><p>我们可以尝试手动完成所有这些操作，但这样我们就会陷入嵌套的订阅反模式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-built_in">this</span>.form.valueChanges<br>    .subscribe(<br>       <span class="hljs-function"><span class="hljs-params">formValue</span> =&gt;</span> &#123;<br>      <br>           <span class="hljs-keyword">const</span> httpPost$ = <br>                 <span class="hljs-built_in">this</span>.http.put(<span class="hljs-string">`/api/course/<span class="hljs-subst">$&#123;courseId&#125;</span>`</span>, formValue);<br><br>           httpPost$.subscribe(<br>               <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> ... handle successful save ...<br>               err =&gt; ... handle save error ...<br>           );<br><br>       &#125;        <br>    );<br><br></code></pre></td></tr></table></figure><p>正如我们所看到的，这将导致我们的代码很快地嵌套在多个级别，这是我们在最初使用 RxJs 时试图避免的问题之一。</p><blockquote><p>让我们把这个新的 httpPost$ Observable 称为内部可观察对象，因为它是在内部嵌套代码块中创建的。</p></blockquote><h3 id="避免嵌套订阅">避免嵌套订阅</h3><p>我们希望以一种更方便的方式完成所有这些过程: 我们希望获取表单值，并将其映射到一个保存的 Observable。这将有效地创建一个更高阶的可观察对象，其中每个值对应一个保存请求。</p><p>然后，我们希望透明地订阅这些网络观察数据，并且一次性直接接收网络响应，以避免任何嵌套。</p><p>如果我们有某种更高阶的 RxJs 映射运算符，我们就可以做到这一切！那为什么我们需要四个不同的操作员呢？</p><p>为了理解这一点，想象一下如果 valueChanges 连续发出多个表单值，并且保存操作需要一些时间才能完成，会发生什么情况:</p><ul><li><p>我们是否应该等待一个保存请求完成后再进行另一个保存？</p></li><li><p>我们应该同时进行多次保存吗？</p></li><li><p>我们应该取消正在进行的保存，重新开始一个新的吗？</p></li><li><p>如果其中一个已经在进行中，我们应该忽略新的保存尝试吗？</p></li></ul><p>在研究这些用例中的每一个之前，让我们回到上面的嵌套订阅代码。</p><p>在嵌套订阅示例中，我们实际上是并行地触发保存操作，这不是我们想要的，因为不能强有力地保证后端将按顺序处理保存操作，并且最后一个有效的表单值确实是存储在后端上的表单值。</p><p>让我们看看如何确保只有在前一次保存完成后才执行保存请求。</p><h3 id="理解-Observable-concat">理解 Observable concat()</h3><p>为了实现顺序保存，我们将引入可观察对象连接的新概念。在这个代码示例中，我们使用 concat () RxJs 函数将两个可观察对象连接起来:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams"><br>const series1<span class="hljs-symbol">$</span> = of(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><br>const series2<span class="hljs-symbol">$</span> = of(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>);<br><br>const result<span class="hljs-symbol">$</span> = concat(series1<span class="hljs-symbol">$</span>, series2<span class="hljs-symbol">$</span>);<br><br>result<span class="hljs-symbol">$</span>.subscribe(console.<span class="hljs-built_in">log</span>);<br><br></code></pre></td></tr></table></figure><p>在使用 of 创建函数创建了两个 Observables series1$ 和 series2$ 之后，我们创建了第三个 result$ Observable，它是串联 series1$ 和 series2$ 的结果。</p><p>下面是这个程序的控制台输出，显示了结果 Observable 发出的值:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br>x<br>y<br><br></code></pre></td></tr></table></figure><p>正如我们所看到的，这些值是将 series1$ 的值与 series2$ 连接在一起的结果。但这里有一个问题: 这只有在这些可观测数据完成的情况下才有效! ！</p><p>of函数的作用是: 创建一个可观察的对象，发出传递给of()的值，然后在发出所有值之后完成 Observable。</p><h3 id="Observable-concat-的弹珠图">Observable concat 的弹珠图</h3><p>为了真正理解发生了什么，我们需要看看 Observable concat 的弹珠图:</p><p><img src="/img/rxjsMap/01-rxjs-concat.png" alt=""></p><p>你注意到第一个可观察值 b 后面的竖条了吗？这标志着第一个值为 a 和 b (series1$)的可观察对象完成的时间点。</p><p>让我们按照时间线一步一步来分析这里发生了什么:</p><ul><li><p>两个可观察对象 series1$ 和 series2$ 被传入 concat() 函数</p></li><li><p>然后 concat ()将订阅第一个可观察对象 series1$，但不订阅第二个可观察对象 series2$(这对于理解连接非常关键)</p></li><li><p>series1$ 发出值 a，该值立即反映在输出 result$ Observable 中</p></li><li><p>series2$ Observable 还没有发出值，因为它还没有被订阅</p></li><li><p>然后 series1$ 将发出 b 值，该值将反映在输出中</p></li><li><p>然后，series1$ 将完成，并且只有在完成之后，concat() 才会订阅 series2$</p></li><li><p>然后，series2$ 值将开始反映在输出中，直到 然后，series2$ 完成</p></li><li><p>请注意，我们可以向 concat() 传递任意多的可观测数据，而不仅仅是像本例中这样的两个</p></li></ul><h3 id="关于Observable-concat-的关键点">关于Observable concat 的关键点</h3><p>正如我们所看到的，Observable 连接就是关于 Observable 的完成（complete)！ 我们取第一个 Observable 并使用它的值，等待它完成，然后我们使用下一个 Observable，依此类推，直到所有 Observable 完成。</p><p>回到我们的高阶 Observable 映射示例，让我们看看串联的概念如何帮助我们。</p><h3 id="使用-Observable-的连接实现顺序保存">使用 Observable 的连接实现顺序保存</h3><p>正如我们所见，为了确保我们的表单值按顺序保存，我们需要获取每个表单值并将其映射到 httpPost$ Observable。</p><p>然后我们需要订阅它，但我们希望在订阅下一个 httpPost$ Observable 之前完成保存。</p><p>然后我们将订阅每个 httpPost$ 并按顺序处理每个请求的结果。 最后，我们需要的是一个混合了以下内容的运算符：</p><ul><li><p>一个高阶映射操作（获取表单值并将其转换为 httpPost$ Observable）</p></li><li><p>使用 concat() 操作，将多个 httpPost$ Observables 连接在一起以确保在前一个正在进行的保存首先完成之前不会进行下一个 HTTP 保存。</p></li></ul><h3 id="RxJs-concatMap-操作符">RxJs concatMap 操作符</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.form.valueChanges<br>    .pipe(<br>        concatMap(<span class="hljs-function"><span class="hljs-params">formValue</span> =&gt;</span> <span class="hljs-built_in">this</span>.http.put(<span class="hljs-string">`/api/course/<span class="hljs-subst">$&#123;courseId&#125;</span>`</span>, <br>                                             formValue))<br>    )<br>    .subscribe(<br>       <span class="hljs-function"><span class="hljs-params">saveResult</span> =&gt;</span>  ... handle successful save ...,<br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ... handle save error ...      <br>    );<br></code></pre></td></tr></table></figure><p>正如我们所见，使用像 concatMap 这样的高阶映射运算符的第一个好处是现在我们不再有嵌套订阅。</p><p>通过使用 concatMap，现在所有表单值都将按顺序发送到后端，如 Chrome DevTools Network 选项卡中所示：</p><p><img src="/img/rxjsMap/03-rxjs-concat-example.png" alt=""></p><h3 id="分解-concatMap-网络日志图">分解 concatMap 网络日志图</h3><p>正如我们所看到的，一个保存 HTTP 请求只有在前一次保存完成后才会启动。以下是 concatMap 操作符如何确保请求始终按顺序发生:</p><ul><li><p>concatMap 正在获取每个表单值并将其转换为保存的 HTTP Observable，称为内部 Observable</p></li><li><p>concatMap 然后订阅内部 Observable 并将其输出发送到结果 Observable</p></li><li><p>第二个表单值可能比在后端保存前一个表单值更快</p></li><li><p>如果发生这种情况，新的表单值将不会立即映射到 HTTP 请求</p></li><li><p>相反， concatMap 将等待先前的 HTTP Observable 完成，然后将新值映射到 HTTP Observable，订阅它并因此触发下一次保存</p></li></ul><p>注意，这里的代码只是保存表单草稿值的实现的基础。您可以将它与其他操作符组合起来，例如，只保存有效的表单值，并使用防抖、节流操作，以确保它们不会太频繁地发生。</p><h3 id="可观察对象的合并（merge）">可观察对象的合并（merge）</h3><p>将 Observable 串联应用于一系列 HTTP 保存操作似乎是确保保存按预期顺序发生的好方法。</p><p>但是在其他情况下，我们希望并行运行，而不需要等待前一个内部 Observable 完成。</p><p>为此，我们有合并 Observable 组合策略！ 与 concat 不同，merge 不会在订阅下一个 Observable 之前等待 Observable 完成。</p><p>相反，merge 同时订阅每个合并的 Observable，然后随着多个值随着时间的推移到达，它将每个源 Observable 的值输出到组合结果 Observable。</p><h3 id="merge-操作的实际例子">merge 操作的实际例子</h3><p>为了清楚地表明 merge 不依赖于 observable 的完成（complete），让我们合并两个永远不会完成的可观测数据，因为它们是 interval Observables:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> series<span class="hljs-number">1</span>$ = interval(<span class="hljs-number">1000</span>).pipe(map(val =&gt; val*<span class="hljs-number">10</span>));<br><br><span class="hljs-attribute">const</span> series<span class="hljs-number">2</span>$ = interval(<span class="hljs-number">1000</span>).pipe(map(val =&gt; val*<span class="hljs-number">100</span>));<br><br><span class="hljs-attribute">const</span> result$ = merge(series<span class="hljs-number">1</span>$, series<span class="hljs-number">2</span>$);<br><br><span class="hljs-attribute">result</span>$.subscribe(console.log);<br></code></pre></td></tr></table></figure><p>使用 interval() 创建的 Observable 将每隔一秒发出值 0、1、2 等，并且永远不会完成。</p><p>请注意，我们对这些区间 Observable 应用了几个 map 运算符，只是为了更容易在控制台输出中区分它们。</p><p>以下是控制台中可见的前几个值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>0<br>10<br>100<br>20<br>200<br>30<br>300<br></code></pre></td></tr></table></figure><h3 id="Merging-and-Observable-Completion">Merging and Observable Completion</h3><p>正如我们所看到的，合并的源可观测数据的值在发出时立即显示在可观测结果中。如果其中一个合并的可观测数据完成，那么当其他可观测数据随着时间的推移到达时，merge 将继续发出它们的值。</p><h3 id="Observable-merge-的弹珠图">Observable merge 的弹珠图</h3><p><img src="/img/rxjsMap/04-rxjs-merge.png" alt=""></p><p>正如我们所见，合并的源 Observables 的值立即显示在输出中。 直到所有合并的 Observable 完成后，结果 Observable 才会完成。</p><p>现在我们了解了合并策略，让我们看看它如何在高阶 Observable 映射的上下文中使用。</p><h3 id="RxJs-mergeMap-运算符">RxJs mergeMap 运算符</h3><p>如果我们将 merge 策略与高阶可观测映射的概念结合起来，我们就得到了 RxJs mergeMap 操作符。让我们看看这个操作符的弹珠图:</p><p><img src="/img/rxjsMap/04-rxjs-mergeMap-2.png" alt=""></p><p>下面是 mergeMap 操作符的工作原理:</p><ul><li><p>与 concatMap 的情况一样，源可观测的每个值仍然被映射到内部的可观测值中</p></li><li><p>与 concatMap 一样，这个内部观察对象也是由 mergeMap 订阅的</p></li><li><p>当内部观察值发出新值时，它们会立即反映在输出观察值中</p></li><li><p>但是与 concatMap 不同的是，在 mergeMap 的情况下，我们不必等待先前的内部可观测值完成，然后再触发下一个内部可观测值</p></li><li><p>这意味着使用 mergeMap (与 concatMap 不同) ，我们可以让多个内部可观测数据随时间重叠，并行发出值，就像我们在图片中看到的用红色突出显示的那样</p></li></ul><h3 id="检查-mergeMap-网络日志">检查 mergeMap 网络日志</h3><p>回到我们之前的表单草案保存示例，很明显，在这种情况下，我们需要的是 concatMap，而不是 mergeMap，因为我们不希望保存并行发生。</p><p>让我们看看如果我们不小心选择了 mergeMap 会发生什么:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-built_in">this</span>.form.valueChanges<br>    .pipe(<br>        mergeMap(<span class="hljs-function"><span class="hljs-params">formValue</span> =&gt;</span> <br>                 <span class="hljs-built_in">this</span>.http.put(<span class="hljs-string">`/api/course/<span class="hljs-subst">$&#123;courseId&#125;</span>`</span>, <br>                               formValue))<br>    )<br>    .subscribe(<br>       <span class="hljs-function"><span class="hljs-params">saveResult</span> =&gt;</span>  ... handle successful save ...,<br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ... handle save error ...      <br>    );<br></code></pre></td></tr></table></figure><p>现在假设用户与表单进行交互并开始快速地输入数据。在这种情况下，我们现在可以在网络日志中看到并行运行的多个保存请求:</p><p><img src="/img/rxjsMap/10-mergeMap-demo.png" alt=""></p><p>正如我们所看到的，请求是并行发生的，在这种情况下是一个错误！在重负载下，这些请求可能会被处理得无序。</p><h3 id="可观察对象的切换">可观察对象的切换</h3><p>现在我们来谈谈另一个 Observable 组合策略：切换。 切换的概念更接近于合并而不是串联，因为我们不等待任何 Observable 终止。</p><p>但是在切换时，与合并不同，如果一个新的 Observable 开始发出值，我们将在订阅新的 Observable 之前取消订阅之前的 Observable。</p><p>Observable 切换就是为了确保未使用的 Observables 的取消订阅逻辑被触发，从而可以释放资源！</p><h3 id="Observable-Switch-的弹珠图">Observable Switch 的弹珠图</h3><p><img src="/img/rxjsMap/05-switch.png" alt=""></p><p>注意对角线，这些不是偶然的！ 在切换策略的情况下，在图中表示高阶 Observable 很重要，它是图像的顶行。</p><p>这个高阶 Observable 发出的值本身就是 Observable。</p><p>对角线从高阶 Observable 顶线分叉的那一刻，是 Observable 值被 switch 发出和订阅的那一刻。</p><h3 id="分解-switch-网络日志图">分解 switch 网络日志图</h3><p>下面是这个图表中的情况:</p><ul><li><p>高阶 Observable 发出它的第一个内部 Observable (a-b-c-d)，它被订阅（通过 switch 策略实现）第一个内部 Observable (a-b-c-d) 发出值 a 和 b，它们立即反映在输出中</p></li><li><p>但随后第二个内部 Observable (e-f-g) 被发射，这触发了第一个内部 Observable (a-b-c-d) 的取消订阅，这是切换的关键部分</p></li><li><p>然后第二个内部 Observable (e-f-g) 开始发出新值，这些值反映在输出中</p></li><li><p>但请注意，第一个内部 Observable (a-b-c-d) 同时仍在发出新值 c 和 d</p></li><li><p>然而，这些后来的值没有反映在输出中，那是因为我们同时取消了第一个内部 Observable (a-b-c-d) 的订阅</p></li></ul><p>我们现在可以理解为什么要用这种不同寻常的方式，用对角线来绘制图表了: 因为我们需要直观地表示每个内部可观测数据是从哪里订阅(或者取消订阅)的，这发生在对角线从高阶可观测数据源分叉出来的点上。</p><h3 id="RxJs-switchMap-运算符">RxJs switchMap 运算符</h3><p>然后我们使用 switch 策略并将其应用于高阶映射。假设我们有一个发出值1、3和5的普通输入流。</p><p>然后我们将把每个值映射到一个可观测值，就像我们在连接映射和合并映射的情况下所做的那样，并获得一个更高阶的可观测值。</p><p>如果我们现在在发出的内部 Observable 之间切换，而不是连接或合并它们，我们最终会得到 switchMap 运算符：</p><p><img src="/img/rxjsMap/06-switchMap-2.png" alt=""></p><h3 id="分解-Observable-switchMap-的弹珠图">分解 Observable switchMap 的弹珠图</h3><p>下面是这个操作符的工作原理:</p><ul><li><p>可观测的源发射值1、3和5</p></li><li><p>然后通过应用映射函数将这些值转换为 Observables</p></li><li><p>当内部观察值发出一个值时，该值将立即反映在输出中</p></li><li><p>但是如果在前一个 Observable 有机会完成之前发出了像 5 这样的新值，则前一个内部 Observable (30-30-30) 将被取消订阅，并且它的值将不再反映在输出中</p></li><li><p>注意上图中红色的 30-30-30 内部 Observable：最后 30 个值没有发出，因为 30-30-30 内部 Observable 被取消订阅</p></li></ul><h3 id="Search-TypeAhead-switchMap-运算符示例">Search TypeAhead-switchMap 运算符示例</h3><p>switchMap 的一个非常常见的用例是 search Typehead。首先，让我们定义我们的源 Observer，它的值本身将触发搜索请求。</p><p>这个源 Observable 将发出值，这些值是用户在输入中键入的搜索文本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> searchText$: Observable&lt;<span class="hljs-built_in">string</span>&gt; = <br>      fromEvent&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-built_in">this</span>.input.nativeElement, <span class="hljs-string">&#x27;keyup&#x27;</span>)<br>    .pipe(<br>        map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.target.value),<br>        startWith(<span class="hljs-string">&#x27;&#x27;</span>)<br>    )<br>    .subscribe(<span class="hljs-built_in">console</span>.log);<br></code></pre></td></tr></table></figure><p>此源 Observable 链接到用户键入其搜索的输入文本字段。 当用户输入单词“Hello World”作为搜索时，这些是 searchText$ 发出的值：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">H</span><br><span class="hljs-built_in">H</span><br>He<br>Hel<br>Hell<br>Hello<br>Hello <br>Hello W<br>Hello W<br>Hello Wo<br>Hello Wor<br>Hello Worl<br>Hello World<br></code></pre></td></tr></table></figure><h3 id="使用防抖并删除重复项">使用防抖并删除重复项</h3><p>注意重复的值，或者是由于使用了两个单词之间的空格，或者是使用 Shift 键将字母 H 和 W 大写。</p><p>为了避免将所有这些值作为单独的搜索请求发送到后端，让我们通过使用 deounceTime 操作符等待用户输入稳定下来:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> searchText$: Observable&lt;<span class="hljs-built_in">string</span>&gt; = <br>      fromEvent&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-built_in">this</span>.input.nativeElement, <span class="hljs-string">&#x27;keyup&#x27;</span>)<br>    .pipe(<br>        map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.target.value),<br>        startWith(<span class="hljs-string">&#x27;&#x27;</span>),<br>        debounceTime(<span class="hljs-number">400</span>)<br>    )<br>    .subscribe(<span class="hljs-built_in">console</span>.log);<br></code></pre></td></tr></table></figure><p>通过使用这个操作符，如果用户以正常速度输入，我们现在在 searchText $的输出中只有一个值:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello World</span><br></code></pre></td></tr></table></figure><p>这已经比我们以前的要好得多了，现在只有当它的稳定值至少为400毫秒时才会发出一个值！</p><p>但是，如果用户在思考搜索时输入速度很慢，以至于两个值之间的时间间隔超过400毫秒，那么搜索流可能是这样的:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">He</span><br><span class="hljs-attribute">Hell</span><br><span class="hljs-attribute">Hello World</span><br></code></pre></td></tr></table></figure><p>此外，用户可以键入一个值，按退格键并再次键入，这可能导致重复的搜索值。我们可以通过添加独特的 distinctUntilChanged 操作符来防止重复搜索的发生。</p><h3 id="取消过时搜索">取消过时搜索</h3><p>但更重要的是，我们需要一种方法来取消以前的搜索，作为一个新的搜索开始。</p><p>这里我们要做的是将每个搜索字符串转换为一个后端搜索请求并订阅它，然后在两个连续的搜索请求之间应用切换策略，如果触发一个新的搜索，则前一个搜索将被取消。</p><p>而这正是 switchMap 操作符要做的事情！下面是使用它的 Typehead 逻辑的最终实现:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> searchText$: Observable&lt;<span class="hljs-built_in">string</span>&gt; = <br>      fromEvent&lt;any&gt;(<span class="hljs-keyword">this</span>.input.nativeElement, <span class="hljs-string">&#x27;keyup&#x27;</span>)<br>    .pipe(<br>        map(<span class="hljs-keyword">event</span> =&gt; <span class="hljs-keyword">event</span>.target.<span class="hljs-keyword">value</span>),<br>        startWith(<span class="hljs-string">&#x27;&#x27;</span>),<br>        debounceTime(<span class="hljs-number">400</span>),<br>        distinctUntilChanged()<br>    ); <br><br><span class="hljs-keyword">const</span> lessons$: Observable&lt;Lesson[]&gt; = searchText$<br>    .pipe(<br>        switchMap(search =&gt; <span class="hljs-keyword">this</span>.loadLessons(search))        <br>    )<br>    .subscribe();<br><br><span class="hljs-function">function <span class="hljs-title">loadLessons</span>(<span class="hljs-params">search:<span class="hljs-built_in">string</span></span>): Observable&lt;Lesson[]&gt;</span> &#123;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">params</span> = <span class="hljs-keyword">new</span> HttpParams().<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;search&#x27;</span>, search);<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.<span class="hljs-keyword">get</span>(`/api/lessons/$&#123;coursesId&#125;`, &#123;<span class="hljs-keyword">params</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在让我们看看 switchMap 操作符的运行情况！如果用户在搜索栏上输入，然后犹豫了一下，输入了其他内容，我们通常可以在网络日志中看到:</p><p><img src="/img/rxjsMap/11-switchMap-example.png" alt=""></p><p>正如我们所看到的，以前的一些搜索已经被取消，因为他们正在进行，这是可怕的，因为这将释放服务器资源，然后可以用于其他事情。</p><h3 id="The-Exhaust-Strategy">The Exhaust Strategy</h3><p>switchMap 操作符对于 typehead 场景是理想的，但是在其他情况下，我们想要做的是忽略源可观察值中的新值，直到前面的值被完全处理。</p><p>例如，假设我们正在触发一个后端保存请求，以响应保存按钮中的单击。我们可以首先尝试使用 concatMap 操作符来实现这一点，以确保按顺序执行保存操作:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">from<span class="hljs-constructor">Event(<span class="hljs-params">this</span>.<span class="hljs-params">saveButton</span>.<span class="hljs-params">nativeElement</span>, &#x27;<span class="hljs-params">click</span>&#x27;)</span><br>    .pipe(<br>        concat<span class="hljs-constructor">Map(()</span> =&gt; this.save<span class="hljs-constructor">Course(<span class="hljs-params">this</span>.<span class="hljs-params">form</span>.<span class="hljs-params">value</span>)</span>)<br>    )<br>    .subscribe<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>这可以确保按顺序保存，但是如果用户多次单击保存按钮，现在会发生什么情况？下面是我们将在网络日志中看到的内容:</p><p><img src="/img/rxjsMap/12-exhaustMap-before.png" alt=""></p><p>正如我们所看到的，每次点击都会触发自己的保存: 如果我们点击20次，就会有20次保存！在这种情况下，我们希望不仅仅是确保保存按顺序发生。</p><p>我们也希望能够忽略一个点击，但只有当一个保存是正在进行。exhaust 组合策略将允许我们这样做。</p><h3 id="exhaust-的弹珠图">exhaust 的弹珠图</h3><p>为了理解 exhaust 是如何工作的，让我们看看这个弹珠图:</p><p><img src="/img/rxjsMap/07-exhaust.png" alt=""></p><p>就像以前一样，我们在第一行有一个更高阶的 Observable，它的值本身就是 Observable，从第一行分叉出来。这是这张图中发生的事情：</p><ul><li><p>就像 switch 的情况一样，exhaust 订阅第一个内部 Observable (a-b-c)</p></li><li><p>像往常一样，值 a、b 和 c 会立即反映在输出中</p></li><li><p>然后发出第二个内部 Observable (d-e-f)，而第一个 Observable (a-b-c) 仍在进行中</p></li><li><p>第二个 Observable 被 exhaust 策略丢弃，并且不会被订阅（这是 exhaust 的关键部分）</p></li><li><p>只有在第一个可观测数据(a-b-c)完成后，exhaust 才会订阅新的可观测数据</p></li><li><p>当第三个 Observable (g-h-i) 发出时，第一个 Observable (a-b-c) 已经完成，所以第三个 Observable 不会被丢弃，会被订阅</p></li><li><p>然后，第三个 Observable 的值 g-h-i 将显示在结果 Observable 的输出中，与输出中不存在的值 d-e-f 不同</p></li></ul><p>就像 concat、merge 和 switch 的情况一样，我们现在可以在高阶映射的上下文中应用 exhaust 策略。</p><h3 id="RxJs-exhaustMap-运算符">RxJs exhaustMap 运算符</h3><p>现在让我们来看一下 exaustMap 操作符的弹珠图。让我们记住，与前面图表的顶行不同，源可观测值1-3-5发出的值不是可观测值。</p><p>相反，这些值可以是鼠标点击:</p><p><img src="/img/rxjsMpa/08-exhaustMap.png" alt=""></p><p>下面是 exhaustMap 图表的情况:</p><ul><li><p>发出值 1，并创建内部 Observable 10-10-10</p></li><li><p>Observable 10-10-10 发出所有值并在源 Observable 中发出值 3 之前完成，因此所有 10-10-10 值在输出中发出</p></li><li><p>在输入中发出一个新值 3，触发一个新的 30-30-30 内部 Observable</p></li><li><p>但是现在，虽然 30-30-30 仍在运行，但我们在源 Observable 中得到了一个新值 5</p></li><li><p>这个值 5 被 exhaust 策略丢弃，这意味着从未创建 50-50-50 Observable，因此 50-50-50 值从未出现在输出中</p></li></ul><h3 id="A-Practical-Example-for-exhaustMap">A Practical Example for exhaustMap</h3><p>现在让我们将这个新的 exhaustMap 操作符应用到我们的保存按钮场景:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">from<span class="hljs-constructor">Event(<span class="hljs-params">this</span>.<span class="hljs-params">saveButton</span>.<span class="hljs-params">nativeElement</span>, &#x27;<span class="hljs-params">click</span>&#x27;)</span><br>    .pipe(<br>        exhaust<span class="hljs-constructor">Map(()</span> =&gt; this.save<span class="hljs-constructor">Course(<span class="hljs-params">this</span>.<span class="hljs-params">form</span>.<span class="hljs-params">value</span>)</span>)<br>    )<br>    .subscribe<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/rxjsMap/12-exhaustMap-after.png" alt=""></p><p>正如我们所看到的，当保存请求被忽略时，我们所做的单击仍然在进行，正如预期的那样！</p><p>注意，如果我们连续点击20次，最终正在进行的保存请求会结束，然后第二个保存请求会开始。</p><h3 id="如何选择正确的映射操作符？">如何选择正确的映射操作符？</h3><p>concatMap, mergeMap, switchMap and exhaustMap 都是相似的，因为它们都是高阶映射操作符。</p><p>但它在许多微妙的方面也是如此不同，以至于没有一个操作符可以被安全地指定为默认值。</p><p>相反，我们可以简单地根据用例选择合适的操作符:</p><ul><li><p>如果我们需要在等待完成时按顺序执行操作，那么 concatMap 是正确的选择</p></li><li><p>对于并行处理，mergeMap 是最好的选择</p></li><li><p>如果我们需要取消逻辑，可以使用 switchMap</p></li><li><p>在当前的 Observables 还在运行的时候忽略了这一点，exhaustMap 就是这样做的</p></li></ul><h3 id="Running-GitHub-repo-with-code-samples">Running GitHub repo (with code samples)</h3><p>如果你想尝试一下这篇文章中的例子，这里有一个<a href="https://github.com/angular-university/rxjs-course/tree/1-operators-finished">仓库</a>，里面包含了这篇文章的运行代码。</p><p>这个存储库包括一个小的 HTTP 后端，它将帮助在一个更现实的场景中测试 RxJ 映射操作符，并包括运行例子，比如表单草稿的预先保存、typeahead、主题和用 Reactive 风格编写的组件的例子:</p><p><img src="/img/rxjsMap/09-demo-app.png" alt=""></p><h3 id="结论">结论</h3><p>正如我们所看到的，RxJs 高阶映射运算符对于在响应式编程中执行一些非常常见的操作(如网络调用)是必不可少的。</p><p>为了真正理解这些映射操作符及其名称，我们需要首先关注理解底层的可观察组合策略 concat、 merge、 switch 和 exhaust。</p><p>我们还需要认识到存在一个更高阶的映射操作，其中值被转换为分离的可观测值，并且这些可观测值被映射操作本身以隐藏的方式订阅。</p><p>选择正确的运算符就是选择正确的内部 Observable 组合策略。 选择错误的运算符通常不会导致程序立即损坏，但随着时间的推移可能会导致一些难以解决的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rxjs</tag>
      
      <tag>operators</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次使用RxJs的操作符优化消息搜索功能</title>
    <link href="/posts/3a4ba2b1/"/>
    <url>/posts/3a4ba2b1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前在开发消息搜索模块时，遇到个问题：如果在防抖允许的时间内，连续两次输入不同的关键词触发http请求，如果网络速度慢，或者接口调用时间长的话，就会导致两个http连接同时在请求，这样就会导致页面会显示两遍不同的请求结果，甚至如果说第一次的请求响应时间快于第二次的话，会造成当搜索的结果显示不正确的现象。当时并没有想到好的解决思路，然后就搁置了，直到最近看到一篇文章，正好解决了我的需求，然后就来优化记录一下。</p><span id="more"></span><h2 id="优化">优化</h2><p>先看一下之前的代码：</p><p><img src="/img/optimize-message/precode.png" alt=""></p><p>其中主要的问题就是订阅层层嵌套，看起来非常乱，也没有一些搜索的优化。</p><p>利用rxjs操作符优化后的代码：</p><p><img src="/img/optimize-message/curcode.png" alt=""></p><p>可以明显的看出来代码变得简洁了许多。</p><p>主要的操作符如下：</p><ul><li><p>forkJoin</p></li><li><p>fromEvent</p></li><li><p>map</p></li><li><p>filter</p></li><li><p>debounceTime</p></li><li><p>distinctUntilChanged</p></li><li><p>switchMap</p></li><li><p>takeUntil</p></li></ul><p>分析：</p><p>首先使用 forkJoin 来聚合三个 Observable，避免了订阅的层层嵌套，使用 fromEvent 操作符替代 input 的 keyup 事件，map 操作符处理流发出输入的值，filter 过滤掉空字符串，不会发送请求，debounceTime 进行防抖处理，用户可以键入一个值，按退格键并再次键入，这可能会导致重复的搜索值。 我们可以通过添加 distinctUntilChanged 操作符来防止重复搜索的发生。switchMap 操作符的作用是如果连续发送了两次请求，且都没有请求完成，则可以取消之前的搜索。最后使用 takeUnit 操作符来管理取消订阅。</p><h2 id="总结">总结</h2><p>RxJs 操作符的合理运用可以优化代码逻辑，但是 RxJs 操作符种类多，而且学起来多少的是有点抽象的，只有在实际的开发中去应用它，才更能体会到它的强大之处～ Keep Learning～</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular中的依赖注入</title>
    <link href="/posts/9a3d5d6c/"/>
    <url>/posts/9a3d5d6c/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>相信angular中的「依赖注入」对于大部分的angular开发者都是一个不容易跨过去的坎，当然我也不例外，这篇文章构思了很久，大概从一年前就想对此来个总结，奈何不知道从何写起，主要原因是在平常的实际开发中用到的依赖注入的知识太浅，所以并不能很好的读懂文档的意思，如今有机会在实际的项目中接触到了更多依赖注入的用法，故此总结一下。</p><span id="more"></span><p>本文内容大部分来源于官方文档，因为文档中的知识点过于零散，东一锤子西一棒子的，摸不着头脑，所以我按照自己的理解，加上实际的demo来梳理一下其中的知识点。</p><h2 id="什么是「依赖注入（dependency-injection）」？">什么是「依赖注入（dependency injection）」？</h2><blockquote><p>依赖注入既是设计模式，同时又是一种机制：当应用程序的一些部件（即一些依赖）需要另一些部件时， 利用依赖注入来创建被请求的部件，并将它们注入到需要它们的部件中。<br>在 Angular 中，依赖通常是服务，但是也可以是值，比如字符串或函数。应用的注入器（它是在启动期间自动创建的）会使用该服务或值的配置好的提供者来按需实例化这些依赖。各个不同的提供者可以为同一个服务提供不同的实现。</p></blockquote><p>上面这段话用我自己的理解，通俗的来讲就是，之前我们如果想要实例化类（class）的一个对象，就要用「new」运算符来实现，现在有了依赖注入这个东西以后就不需要我们自己亲自动手去new一个对象了，我们只需要在用到的地方使用angular的「依赖注入」的语法，就可以拿到我们想要的对象了，而帮助我们创建对象的这个东西叫做「注入器」，注入器这个东西，很抽象，我们看不见摸不着，这是angular在运行过程中帮助我们自动创建的。</p><p>先把几个名词搞清楚，「服务」、「注入器」、「DI令牌」、「提供者」。</p><h2 id="服务">服务</h2><p>在 Angular 中，服务就是一个带有 @Injectable 装饰器的类，它封装了可以在应用程序中复用的非 UI 逻辑和代码。 Angular 把组件和服务分开，是为了增进模块化程度和可复用性。</p><p>@Injectable 元数据让服务类能用于依赖注入机制中。可注入的类是用提供者进行实例化的。 各个注入器会维护一个提供者的列表，并根据组件或其它服务的需要，用它们来提供服务的实例。</p><h2 id="DI令牌">DI令牌</h2><p>一种用来查阅的令牌，它关联到一个依赖提供者，用于依赖注入系统中，DI令牌和注入的依赖项相映射，可以把DI令牌作为key来找到依赖项。</p><p>令牌通常是 Type 或 InjectionToken 的实例，但也可以是 any 实例。</p><h2 id="提供者">提供者</h2><p>一个实现了 Provider 接口的对象。一个提供者对象定义了如何获取与 DI 令牌（token） 相关联的可注入依赖。 注入器会使用这个提供者来创建它所依赖的那些类的实例。</p><p>Angular 会为每个注入器注册一些 Angular 自己的服务。你也可以注册应用自己所需的服务提供者。</p><p>依赖提供者会使用 DI 令牌来配置注入器，注入器会用它来提供这个依赖值的具体的、运行时版本。</p><figure class="highlight coq"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs coq">type Provider = TypeProvider | <span class="hljs-type">ValueProvider</span> | <span class="hljs-type">ClassProvider</span> | <span class="hljs-type">ConstructorProvider</span> | <span class="hljs-type">ExistingProvider</span> | <span class="hljs-type">FactoryProvider</span> | <span class="hljs-type">any</span>[];<br></code></pre></td></tr></table></figure><p>ClassProvider</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">ClassProvider</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">ClassSansProvider</span> &#123;<br>  <span class="hljs-comment">// DI 令牌</span><br>  provide: any<br>  multi?: <span class="hljs-built_in">bool</span>ean<br><br>  <span class="hljs-comment">// 继承自 core/ClassSansProvider</span><br>  useClass: Type&lt;any&gt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注入器">注入器</h2><p>Angular 依赖注入系统中可以在缓存中根据名字查找依赖，也可以通过配置过的「提供者」来创建依赖。 启动过程中会自动为每个模块创建一个注入器，并被组件树继承。</p><ul><li><p>注入器会提供依赖的一个单例，并把这个单例对象注入到多个组件中。</p></li><li><p>模块和组件级别的注入器树可以为它们拥有的组件及其子组件提供同一个依赖的不同实例。</p></li><li><p>你可以为同一个依赖使用不同的提供者来配置这些注入器，这些提供者可以为同一个依赖提供不同的实现。</p></li></ul><h2 id="怎么注入一个依赖？">怎么注入一个依赖？</h2><p>以最常用的服务为例，在组件中注入一个服务：</p><p>上面👆介绍了，在 Angular 中服务就是一个带有 @Injectable() 装饰器的类，可以把它作为依赖，注入到组件中。同样，也要使用 @Injectable() 装饰器来表明一个组件或其它类（比如另一个服务、管道或 NgModule）拥有一个依赖，我们实际项目中绝大部分注入的依赖都是服务。</p><ul><li><p><strong>注入器</strong>是主要的机制。Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建「注入器」。</p></li><li><p>该注入器会创建依赖、维护一个容器来管理这些依赖，并尽可能复用它们。</p></li><li><p><strong>提供者</strong>是一个对象，用来告诉注入器应该如何获取或创建依赖。</p></li></ul><p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个<strong>提供者</strong>，以便注入器可以使用这个提供者来创建新实例。对于服务，该提供者通常就是服务类本身。</p><blockquote><p>依赖不一定是服务 —— 它还可能是函数或值。</p></blockquote><p>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。如下：HeroListComponent 的构造函数中需要 HeroService</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> service: HeroService)</span> <span class="hljs-comment">&#123; &#125;</span></span><br></code></pre></td></tr></table></figure><p>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在实例，注入器就会使用以前注册的服务提供者来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p><p>当所有请求的服务已解析并返回时，Angular 可以用这些服务实例为参数，调用该组件的构造函数。</p><p>注入过程可以用下方非常形象和经典的一张图来概括：</p><p><img src="/img/inject/injector-injects.png" alt=""></p><p>个人理解：图中的Injector就是注入器，它管理着很多的依赖，Angular中「依赖项」和「DI令牌」相映射，「DI令牌」作为映射的key，「依赖项」作为映射的value，当发现构造函数中依赖HeroService时，注入器就会把HeroService当作「DI令牌」去注入器中去查找相应的「依赖项」，找到依赖项以后，然后再去查找该依赖有没有已经实例化好的对象，如果有就直接返回该对象，如果没有，注入器就会根据该依赖的「提供者」去创建对象，所以说对象是由注入器根据提供者创建的。「服务」的「提供者定义对象」默认就是 useClass，也就是说注入器会通过 new 的方式创建一个对象，此外「提供者定义对象」还可以是 useValue 、useExisting、useFactory等。</p><h2 id="提供服务的三种方式">提供服务的三种方式</h2><p>对于要用到的任何服务，你必须至少注册一个提供者。服务可以在自己的元数据中把自己注册为提供者，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供者。要注册提供者，就要在服务的 @Injectable() 装饰器中提供它的元数据，或者在 @NgModule() 或 @Component() 的元数据中。</p><ol><li>默认情况下，Angular CLI 的 ng generate service 命令会在 @Injectable() 装饰器中提供元数据来把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供者：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@Injectable</span>(&#123;<br> providedIn: <span class="hljs-string">&#x27;root&#x27;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。这种在 @Injectable 元数据中注册提供者的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小。</p><ol start="2"><li>当你使用特定的 NgModule 注册提供者时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 @NgModule() 装饰器中的 providers 属性：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@NgModule</span>(&#123;<br>  providers: [<br>  BackendService,<br>  Logger<br> ],<br> …<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>当你在组件级注册提供者时，你会为该组件的每一个新实例提供该服务的一个新实例。要在组件级注册，就要在 @Component() 元数据的 providers 属性中注册服务提供者。</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span>(&#123;<br>  <span class="hljs-attribute">selector</span>:    <span class="hljs-string">&#x27;app-hero-list&#x27;</span>,<br>  <span class="hljs-attribute">templateUrl</span>: <span class="hljs-string">&#x27;./hero-list.component.html&#x27;</span>,<br>  <span class="hljs-attribute">providers</span>:  [ HeroService ]<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="定义提供者">定义提供者</h2><h3 id="类提供者">类提供者</h3><p>类提供者的语法实际上是一种简写形式，它会扩展成一个由 Provider 接口定义的提供者配置对象。下面的代码片段展示了 providers 中给出的类会如何扩展成完整的提供者配置对象。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">providers</span>:<span class="hljs-meta"> [Logger]</span><br></code></pre></td></tr></table></figure><p>Angular 把这个 providers 值扩展为一个完整的提供者对象，如下所示。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[&#123; provide: Logger, useClass: Logger &#125;]<br></code></pre></td></tr></table></figure><p>扩展的提供者配置是一个具有两个属性的对象字面量：</p><ul><li><p>provide 属性存有令牌，它作为一个 key，在定位依赖值和配置注入器时使用。</p></li><li><p>第二个属性是一个提供者定义对象，它告诉注入器要如何创建依赖值。提供者定义对象中的 key 可以是 useClass —— 就像这个例子中一样。也可以是 useExisting、useValue 或 useFactory。每一个 key 都用于提供一种不同类型的依赖，我们稍后会讨论。</p></li></ul><h2 id="别名类提供者">别名类提供者</h2><p>要为类提供者设置别名，请在 providers 数组中使用 useExisting 属性指定别名和类提供者。</p><p>在下面的例子中，当组件请求新的或旧的记录器时，注入器都会注入一个 NewLogger 的实例。通过这种方式，OldLogger 就成了 NewLogger 的别名。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">[ NewLogger,<br>  <span class="hljs-regexp">//</span> Alias OldLogger w/ reference to NewLogger<br>  &#123; provide: OldLogger, useExisting: NewLogger&#125;]<br></code></pre></td></tr></table></figure><p>请确保你没有使用 useClass 来把 OldLogger 设为 NewLogger 的别名，因为如果这样做它就会创建两个不同的 NewLogger 实例。</p><h2 id="注入一个配置对象">注入一个配置对象</h2><p>常用的对象字面量是配置对象。下列配置对象包括应用的标题和 Web API 的端点地址。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HERO_DI_CONFIG: AppConfig = &#123;<br>  apiEndpoint: <span class="hljs-string">&#x27;api.heroes.com&#x27;</span>,<br>  title: <span class="hljs-string">&#x27;Dependency Injection&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>定义和使用一个 InjectionToken 对象来为非类的依赖选择一个提供者令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; InjectionToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> APP_CONFIG = <span class="hljs-keyword">new</span> InjectionToken&lt;AppConfig&gt;(<span class="hljs-string">&#x27;app.config&#x27;</span>);<br></code></pre></td></tr></table></figure><p>接着，用 APP_CONFIG 这个 InjectionToken 对象在组件中注册依赖提供者。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">providers:</span> [&#123; <span class="hljs-attr">provide:</span> <span class="hljs-string">APP_CONFIG</span>, <span class="hljs-attr">useValue:</span> <span class="hljs-string">HERO_DI_CONFIG</span> &#125;]<br></code></pre></td></tr></table></figure><p>现在，借助参数装饰器 @Inject()，你可以把这个配置对象注入到构造函数中。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(@Inject(APP_CONFIG)</span> <span class="hljs-title">config</span>:</span> AppConfig) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  this.title = config.title;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="接口和依赖注入">接口和依赖注入</h2><p>虽然 TypeScript 的 AppConfig 接口可以在类中提供类型支持，但它在依赖注入时却没有任何作用。在 TypeScript 中，接口是一项设计期工件，它没有可供 DI 框架使用的运行时表示形式或令牌。</p><p>当转译器把 TypeScript 转换成 JavaScript 时，接口就会消失，因为 JavaScript 没有接口。</p><p>由于 Angular 在运行期没有接口，所以该接口不能作为令牌，也不能注入它。</p><h2 id="使用工厂提供者">使用工厂提供者</h2><p>要想根据运行前尚不可用的信息创建可变的依赖值，可以使用工厂提供者。</p><p>在下面的例子中，只有授权用户才能看到 HeroService 中的秘密英雄。授权可能在单个应用会话期间发生变化，比如改用其他用户登录。</p><p>要想在 UserService 和 HeroService 中保存敏感信息，就要给 HeroService 的构造函数传一个逻辑标志来控制秘密英雄的显示。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">private</span> logger: Logger,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">private</span> isAuthorized: <span class="hljs-built_in">boolean</span></span>)</span> &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-title">getHeroes</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> auth = <span class="hljs-built_in">this</span>.isAuthorized ? <span class="hljs-string">&#x27;authorized &#x27;</span> : <span class="hljs-string">&#x27;unauthorized&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.logger.log(<span class="hljs-string">`Getting heroes for <span class="hljs-subst">$&#123;auth&#125;</span> user.`</span>);<br>  <span class="hljs-keyword">return</span> HEROES.filter(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> <span class="hljs-built_in">this</span>.isAuthorized || !hero.isSecret);<br>&#125;<br></code></pre></td></tr></table></figure><p>要实现 isAuthorized 标志，可以用工厂提供者来为 HeroService 创建一个新的 logger 实例。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const heroServiceFactory =<span class="hljs-function"> (<span class="hljs-params">logger</span>: L<span class="hljs-params">ogger</span>, <span class="hljs-params">userService</span>: U<span class="hljs-params">serService</span>) =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-constructor">HeroService(<span class="hljs-params">logger</span>, <span class="hljs-params">userService</span>.<span class="hljs-params">user</span>.<span class="hljs-params">isAuthorized</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个工厂函数可以访问 UserService。你可以同时把 Logger 和 UserService 注入到工厂提供者中，这样注入器就可以把它们传给工厂函数了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">export</span> <span class="hljs-string">const</span> <span class="hljs-string">heroServiceProvider</span> <span class="hljs-string">=</span><br>  &#123; <span class="hljs-attr">provide:</span> <span class="hljs-string">HeroService</span>,<br>    <span class="hljs-attr">useFactory:</span> <span class="hljs-string">heroServiceFactory</span>,<br>    <span class="hljs-attr">deps:</span> [<span class="hljs-string">Logger</span>, <span class="hljs-string">UserService</span>]<br>  &#125;<span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><ul><li><p>useFactory 字段指定该提供者是一个工厂函数，其实现代码是 heroServiceFactory</p></li><li><p>deps 属性是一个提供者令牌数组。Logger 和 UserService 类都是自己类提供者的令牌。该注入器解析了这些令牌，并把相应的服务注入到 heroServiceFactory 工厂函数的参数中。</p></li></ul><p>通过把工厂提供者导出为变量 heroServiceProvider，就能让工厂提供者变得可复用。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; heroServiceProvider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hero.service.provider&#x27;</span>;<br><br>@Component(&#123;<br>  selector: <span class="hljs-string">&#x27;app-heroes&#x27;</span>,<br>  providers: [ heroServiceProvider ],<br>  template: `<span class="javascript"></span><br><span class="javascript">    &lt;h2&gt;Heroes&lt;/h2&gt;</span><br><span class="javascript">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">app-hero-list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-hero-list</span>&gt;</span></span></span><br><span class="javascript">  </span>`<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> &#123; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="多级注入器">多级注入器</h2><p>Angular 中有两个注入器层次结构：</p><ul><li><p>ModuleInjector 层次结构：使用 @NgModule() 或 @Injectable() 注解在此层次结构中配置 ModuleInjector。</p></li><li><p>ElementInjector 层次结构：在每个 DOM 元素上隐式创建。默认情况下，ElementInjector 是空的，除非你在 @Directive() 或 @Component() 的 providers 属性中配置它。</p></li></ul><h3 id="ModuleInjector">ModuleInjector</h3><p>可以通过以下两种方式之一配置 ModuleInjector ：</p><ul><li><p>使用 @Injectable() 的 providedIn 属性引用 @NgModule() 或 root</p></li><li><p>使用 @NgModule() 的 providers 数组</p></li></ul><h4 id="摇树优化与-Injectable">摇树优化与 @Injectable()</h4><blockquote><p>使用 @Injectable() 的 providedIn 属性优于 @NgModule() 的 providers 数组，因为使用 @Injectable() 的 providedIn 时，优化工具可以进行摇树优化，从而删除你的应用程序中未使用的服务，以减小捆绑包尺寸。摇树优化对于库特别有用，因为使用该库的应用程序不需要注入它。</p></blockquote><p>ModuleInjector 由 @NgModule.providers 和 NgModule.imports 属性配置。ModuleInjector 是可以通过 NgModule.imports 递归找到的所有 providers 数组的扁平化。</p><p>子 ModuleInjector 是在惰性加载其它 @NgModules 时创建的。</p><h4 id="平台注入器">平台注入器</h4><p>在 root 之上还有两个注入器，一个是额外的 ModuleInjector，一个是 NullInjector()。</p><p>另一个额外的ModuleInjector这里不作赘述，感兴趣的可以去官网了解。</p><p>层次结构中的下一个父注入器是 NullInjector()，它是树的顶部。如果你在树中向上走了很远，以至于要在 NullInjector() 中寻找服务，那么除非使用 @Optional()，否则将收到错误消息，因为最终所有东西都将以 NullInjector() 结束并返回错误，或者对于 @Optional()，返回 null。</p><p>下图展示了前面各段落描述的 root ModuleInjector 及其父注入器之间的关系。</p><p><img src="/img/inject/injectors.svg" alt=""></p><h3 id="ElementInjector">ElementInjector</h3><p>Angular 会为每个 DOM 元素隐式创建 ElementInjector。</p><p>可以用 @Component() 装饰器中的 providers 或 viewProviders 属性来配置 ElementInjector 以提供服务。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span>(&#123;<br>  …<br>  <span class="hljs-attribute">providers</span>: [&#123; <span class="hljs-attribute">provide</span>: ItemService, <span class="hljs-attribute">useValue</span>: &#123; <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;lamp&#x27;</span> &#125; &#125;]<br>&#125;)<br>export class TestComponent<br></code></pre></td></tr></table></figure><h3 id="解析规则">解析规则</h3><p>当为组件/指令解析令牌时，Angular 分为两个阶段来解析它：</p><ol><li><p>针对 ElementInjector 层次结构（其父级）。</p></li><li><p>针对 ModuleInjector 层次结构（其父级）。</p></li></ol><p>当组件声明依赖项时，Angular 会尝试使用它自己的 ElementInjector 来满足该依赖。 如果组件的注入器缺少提供者，它将把请求传给其父组件的 ElementInjector。</p><p>这些请求将继续转发，直到 Angular 找到可以处理该请求的注入器或用完祖先 ElementInjector。</p><p>如果 Angular 在任何 ElementInjector 中都找不到提供者，它将返回到发起请求的元素，并在 ModuleInjector 层次结构中进行查找。如果 Angular 仍然找不到提供者，它将引发错误。</p><p>如果你已在不同级别注册了相同 DI 令牌的提供者，则 Angular 会用遇到的第一个来解析该依赖。比如，如果提供者已经在需要此服务的组件中本地注册了，则 Angular 不会再寻找同一服务的其它提供者。</p><h3 id="解析修饰符">解析修饰符</h3><p>可以使用 @Optional()，@Self()，@SkipSelf() 和 @Host() 来修饰 Angular 的解析行为。从 @angular/core 导入它们，并在注入服务时在组件类构造函数中使用它们。</p><h4 id="修饰符的类型">修饰符的类型</h4><p>解析修饰符分为三类：</p><ul><li><p>如果 Angular 找不到你要的东西该怎么办，用 @Optional()</p></li><li><p>从哪里开始寻找，用 @SkipSelf()</p></li><li><p>到哪里停止寻找，用 @Host() 和 @Self()</p></li></ul><p>默认情况下，Angular 始终从当前的 Injector 开始，并一直向上搜索。修饰符使你可以更改开始（默认是自己）或结束位置。</p><p>另外，你可以组合除 @Host() 和 @Self() 之外的所有修饰符，当然还有 @SkipSelf() 和 @Self()。</p><h4 id="Optional">@Optional()</h4><p>@Optional() 允许 Angular 将你注入的服务视为可选服务。这样，如果无法在运行时解析它，Angular 只会将服务解析为 null，而不会抛出错误。在下面的范例中，服务 OptionalService 没有在 @NgModule() 或组件类中提供，所以它没有在应用中的任何地方。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">OptionalComponent</span> &#123;<br>  <span class="hljs-selector-tag">constructor</span>(<span class="hljs-variable">@Optional</span>() public optional?: OptionalService) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Self">@Self()</h4><p>使用 @Self() 让 Angular 仅查看当前组件或指令的 ElementInjector。</p><p>@Self() 的一个好例子是要注入某个服务，但只有当该服务在当前宿主元素上可用时才行。为了避免这种情况下出错，请将 @Self() 与 @Optional() 结合使用。</p><h4 id="SkipSelf">@SkipSelf()</h4><p>@SkipSelf() 与 @Self() 相反。使用 @SkipSelf()，Angular 在父 ElementInjector 中而不是当前 ElementInjector 中开始搜索服务。</p><h4 id="Host">@Host()</h4><p>@Host() 使你可以在搜索提供者时将当前组件指定为注入器树的最后一站。即使树的更上级有一个服务实例，Angular 也不会继续寻找。</p><h2 id="最后">最后</h2><p>由于angular的依赖注入知识体系实在是过于庞大，本文也仅仅是了解了下它的基础用法，但是掌握了这些也足够我们在平常的开发中使用了，当然只学习用法和真正实践还是有很大区别的，有机会还是要多实践，除此之外angular还有很多依赖注入的高级实践，等以后有机会学习实践以后会再来补充文章。最后，angular官网文档yyds！</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>依赖注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React学习笔记-基础语法</title>
    <link href="/posts/354b326f/"/>
    <url>/posts/354b326f/</url>
    
    <content type="html"><![CDATA[<p>由于ng写的枯燥无味，所以便趁着晚上无聊时间学习react，卷死你们！</p><p>此笔记是记录学习react的第一篇文章，主要学到了创建react组件的方式、jsx的基础语法以及react中的this指向问题。</p><span id="more"></span><h3 id="创建react组件的方式">创建react组件的方式</h3><p>有两种方式可以创建组件：函数式组件和类组件。如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 函数式</span><br>function <span class="hljs-type">Welcome</span>(props) &#123;<br>  <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span>, &#123;props.name&#125;&lt;/h1&gt;;<br>&#125;<br><br><span class="hljs-comment">// 类组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span>, &#123;<span class="hljs-keyword">this</span>.props.name&#125;&lt;/h1&gt;;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在不考虑hooks之前，类组件就是比函数组件多了state（状态）功能，适合复杂功能，当然hooks就等以后学到再说吧。</p><h3 id="JSX">JSX</h3><p>在react中使用jsx来构建界面，最终由babel编译器转为普通的js代码。</p><p>JSX全称是JavaScript XML 是对JavaScript的一种扩展。下面是几种语法：</p><ol><li><p>定义虚拟dom时，不要写引号。</p></li><li><p>标签中混入js表达式时要用{}。</p></li><li><p>样式的类名不要用class，要换成className。</p></li><li><p>内联样式，要用{{key: value}}的形式去写。</p></li><li><p>只能有一个根标签，且标签必须闭合。</p></li><li><p>标签首字母：如果是大写，则babel会以组件去解析，否则会以HTML标签去解析。</p></li><li><p>点击事件要写成 onClick={this.handleClick}的形式，onClick驼峰写法。</p></li></ol><h3 id="react中的this指向问题">react中的this指向问题</h3><p>先看一下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">frameWork</span>: [<span class="hljs-string">&#x27;Angular&#x27;</span>,<span class="hljs-string">&#x27;React&#x27;</span>,<span class="hljs-string">&#x27;Vue&#x27;</span>]&#125;;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-keyword">return</span> (<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">main</span>&#x27;&#125;&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;fontSize:</span>&#x27;<span class="hljs-attr">25px</span>&#x27;,<span class="hljs-attr">fontWeight:</span> &#x27;<span class="hljs-attr">bold</span>&#x27;&#125;&#125;&gt;</span>前端三大框架<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">               &#123;this.state.frameWork.map((item,index) =&gt;</span><br><span class="xml">                   (<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">list</span>&#x27;&#125; <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>))&#125;</span><br><span class="xml">           <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   )<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 此处打印的this会是undefined！</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里打印的this的undefined的原因如下：</p><ol><li><p>在react中的点击事件并不是由组件类的实例直接调用的，而是由window调用的，上面的代码中的onClick是一个赋值语句，并没有运行handleClick方法，而是由window调用的，相当于 window.handleClick()</p></li><li><p>handleClick方法是类中的实例方法，在类的实例方法内部会默认启用’ use strict '严格模式，在严格模式下，方法内部的this就变成了undefined。</p></li></ol><p>知道了原因以后解决方法如下：</p><ol><li>利用bind方法，显示的改变this指向。在construct构造方法中加入：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里的this指的是组件类的实例对象</span><br><span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>利用ES6的箭头函数，箭头函数中是没有this的，内部的this是指它上一层的作用域中的this。</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 把函数改造成箭头函数<br><span class="hljs-function"> <span class="hljs-title">handleClick</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>总结一下用到的js的知识点：</p><ol><li><p>原型与原型链（类的继承）</p></li><li><p>this的指向问题（箭头函数中的this）</p></li><li><p>js中的严格模式</p></li><li><p>显式改变this的指向的方法（bind、call、apply的区别）</p></li></ol><p>以上。由于笔者水平有限，若有错误敬请指正，欢迎评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>react基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular中防抖的实现</title>
    <link href="/posts/445dfd0e/"/>
    <url>/posts/445dfd0e/</url>
    
    <content type="html"><![CDATA[<p>在angular中的防抖主要是利用了rxjs中的debounce操作符，非常简洁方便！</p><span id="more"></span><p>下面主要是介绍其三种写法，主要分为两类，不封装指令的防抖和封装成指令的防抖，其中封装成指令的防抖又有两种写法：利用@HostListener装饰器和Renderer2.listen方法。</p><h3 id="不封装指令的防抖">不封装指令的防抖</h3><p>html</p><figure class="highlight handlebars"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;syn-margin-24&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    默认时间500ms，只有500ms以内没有事件触发才会执行。</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;syn-margin-24 label-font&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">total</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">nz-button</span> <span class="hljs-attr">nzType</span>=<span class="hljs-string">&quot;primary&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;add($event)&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> <span class="hljs-attr">nzType</span>=<span class="hljs-string">&quot;plus&quot;</span> <span class="hljs-attr">nzTheme</span>=<span class="hljs-string">&quot;outline&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="xml">    Add</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; debounceTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Component,OnDestroy&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Subscription, Subject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;syn-debounce&#x27;</span>,<br>  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./debounce.component.html&#x27;</span>,<br>  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;./debounce.component.scss&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebounceComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span></span>&#123;<br>  <span class="hljs-keyword">public</span> total: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">public</span> debounceTime: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;<br>  <span class="hljs-keyword">public</span> subscription = <span class="hljs-keyword">new</span> Subscription();<br>  <span class="hljs-keyword">public</span> subject$ = <span class="hljs-keyword">new</span> Subject();<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.subject$.pipe(debounceTime(<span class="hljs-built_in">this</span>.debounceTime)).subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">this</span>.total+=<span class="hljs-number">1</span>);<br>   &#125;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">$event: MouseEvent</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subject$.next($event);<br>  &#125;<br>  ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription.unsubscribe();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="/img/debounce/article-1.gif" alt=""></p><p>定义了一个“主体”Subject，它既是观察者，也可以是订阅者，每次点击事件时调用add方法，然后使用next方法发送事件，然后由于subject$同时subscribe(订阅)了事件，所以会经过rxjs的debounce运算符的处理，其接收一个number类型的值，单位ms，就是我们设置的防抖时间。</p><h3 id="指令-HostListener">指令-@HostListener</h3><p>在实际的项目中用到防抖的地方肯定不只有一处，所以此时我们应该封装出一个防抖的指令使用,在ng中监听dom事件的方法我所了解的有两种：@HostListener监听和Renderer2.listen方法。思路都是一样的，都是利用了rxjs，只不过就是监听元素事件的写法不同而已。</p><p>ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Directive, EventEmitter, HostListener, Input, OnDestroy, OnInit, Output &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Subject, Subscription &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; debounceTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>基于rxjs的debounceTime操作符的防抖</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Directive</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;[synDebounceClick]&#x27;</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebounceClickDirective</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span>, <span class="hljs-title">OnDestroy</span> </span>&#123;<br>  <span class="hljs-meta">@Input</span>() debounceTime = <span class="hljs-number">500</span>;<br>  <span class="hljs-meta">@Output</span>(<span class="hljs-string">&#x27;synDebounceClick&#x27;</span>) debounceClick = <span class="hljs-keyword">new</span> EventEmitter();<br>  <span class="hljs-keyword">private</span> subject$ = <span class="hljs-keyword">new</span> Subject();<br>  <span class="hljs-keyword">private</span> subscription!: Subscription;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.subject$.pipe(<br>      debounceTime(<span class="hljs-built_in">this</span>.debounceTime)<br>    ).subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">this</span>.debounceClick.emit(e))<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">ngOnDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription.unsubscribe();<br>  &#125;<br>  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,[<span class="hljs-string">&#x27;$event&#x27;</span>])<br>  <span class="hljs-function"><span class="hljs-title">clickEvent</span>(<span class="hljs-params">event: <span class="hljs-built_in">any</span></span>)</span> &#123;<br>    event.preventDefault();<br>    event.stopPropagation();<br>    <span class="hljs-built_in">this</span>.subject$.next(event);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>导入相应的module后然后在HTML模板中使用即可</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> nz-<span class="hljs-keyword">button</span> nzType=<span class="hljs-string">&quot;primary&quot;</span> (synDebounceClick)=<span class="hljs-string">&quot;add()&quot;</span>&gt;Primary <span class="hljs-keyword">Button</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="指令-Renderer2-listen">指令-Renderer2.listen</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; debounceTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Subject, Subscription &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Directive, ElementRef, Renderer2, OnInit, Input, Output, EventEmitter, OnDestroy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-meta">@Directive</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;[synDebounceRendererClick]&#x27;</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebounceRendererDirective</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span>, <span class="hljs-title">OnDestroy</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> subject$ = <span class="hljs-keyword">new</span> Subject();<br>  <span class="hljs-keyword">private</span> subscription!: Subscription;<br>  <span class="hljs-meta">@Input</span>() debounceTime: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;<br>  <span class="hljs-meta">@Output</span>(<span class="hljs-string">&#x27;synDebounceRendererClick&#x27;</span>) synDebounceRendererClick = <span class="hljs-keyword">new</span> EventEmitter();<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> _elementRef: ElementRef, <span class="hljs-keyword">private</span> _renderer2: Renderer2</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.subject$.pipe(debounceTime(<span class="hljs-built_in">this</span>.debounceTime))<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">this</span>.synDebounceRendererClick.emit());<br>  &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>._renderer2.listen(<span class="hljs-built_in">this</span>._elementRef.nativeElement,<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      e.stopPropagation();<br>      e.preventDefault();<br>      <span class="hljs-built_in">this</span>.subject$.next(e);<br>    &#125;);<br>  &#125;<br>  ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription.unsubscribe();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>html</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> nz-<span class="hljs-keyword">button</span> nzType=<span class="hljs-string">&quot;primary&quot;</span> (synDebounceRendererClick)=<span class="hljs-string">&quot;add()&quot;</span>&gt;Primary <span class="hljs-keyword">Button</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>以上就是我所知道的三种写法，至于@HostListener和Renderer2.listen()有什么区别我也不是很清楚多方查阅也没有得到具体的结果，我所了解的是@HostListener只能监听宿主元素，而Renderer2.listen()可以监听任意元素，如果还有其它不同请在评论区留言交流！</p><p>笔者水平有限，若有错误敬请指正，不明白的地方欢迎评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>防抖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript Element.getBoundingClientRect API</title>
    <link href="/posts/b6e78c84/"/>
    <url>/posts/b6e78c84/</url>
    
    <content type="html"><![CDATA[<p>日常开发中遇到一个需求是需要计算某个字符串的长度，用到了 Element.getBoundingClientRect() 方法。</p><span id="more"></span><h3 id="Element-getBoundingClientRect-介绍">Element.getBoundingClientRect() 介绍</h3><p>看一下mdn的解释：</p><blockquote><p>The Element.getBoundingClientRect() method returns a DOMRect object providing information about the size of an element and its position relative to the viewport.</p></blockquote><p>说的是这个函数会返回一个DOMRect对象，这个对象中会包含当前dom元素的一些信息，如相对于视窗的位置、宽高等。</p><p>需要注意的是这里返回的元素的宽高是包含元素的border-width和padding的，因为盒子默认的是标准盒模型（standard box），如果设置了box-sizing：border-box的话，则获取到的宽高只包含元素内容的宽高。</p><h4 id="DOMRect对象">DOMRect对象</h4><p>DOMRect对象描述了一个矩形的大小和位置，属性都是只读的。</p><p>通过mdn上的一个demo看一下都有哪些属性吧:</p><p>html</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;div&gt;</span><span class="hljs-section">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p>javascript</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-built_in">rect</span> = elem.getBoundingClientRect();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">rect</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">rect</span>[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> para = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);<br>    para.textContent  = <span class="hljs-string">`<span class="hljs-subst">$&#123; key &#125;</span> : <span class="hljs-subst">$&#123; rect[key] &#125;</span>`</span>;<br>    <span class="hljs-built_in">document</span>.body.appendChild(para);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codepen.io/yanglusen/pen/YzEVGgq">传送门</a></p><p>运行结果如下：</p><p><img src="/img/calculate/result.png" alt=""></p><p>这里的width属性正是我们想要的元素的宽度。</p><p>这里解释下，代码里没有设置margin:8px,为什么会有8像素的margin呢，是以为codePen这个在线编辑器的body有默认的8px的margin。</p><h3 id="最终代码">最终代码</h3><p>其实知道了关键的方法代码也就出来了，如下这是ts的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算字符串的像素长度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>str 输入的字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fontSize 字体大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>输入字符串的像素长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> getTextWidth(str: <span class="hljs-built_in">string</span>,<span class="hljs-attr">fontSize</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span> &#123;<br> <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br> ele.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;<br> ele.style.whiteSpace = <span class="hljs-string">&#x27;nowrap&#x27;</span>;<br> ele.style.fontSize = fontSize;<br> ele.style.fontFamily = <span class="hljs-string">&#x27;inherit&#x27;</span>;<br> ele.style.opacity = <span class="hljs-string">&#x27;0&#x27;</span>;<br> ele.innerText = str;<br> <span class="hljs-built_in">document</span>.body.append(ele);<br> result = ele.getBoundingClientRect().width;<br> <span class="hljs-built_in">document</span>.body.removeChild(ele);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是字符串的字体样式如fontFamily、fontSize等都会影响其宽度的，因为我的需求中字体都是Chrome默认的，只有大小会不同，所以单独把字体大小作为形参提了出来。</p><p>笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ng-zorro中实现两个table同步滚动效果</title>
    <link href="/posts/1f09b34d/"/>
    <url>/posts/1f09b34d/</url>
    
    <content type="html"><![CDATA[<p>某天下午，同事向我请教了一个问题，需求是有两个table，当table存在滚动条时，在某一个table上滚动，那么另一个table也要同步滚动，巧的是我也不会，但是我闲着没事，帮着研究了一下。</p><span id="more"></span><p>技术栈是： angular8 + ng-zorro组件库</p><p>先看效果和代码：</p><p><img src="/img/ng-zorro-scroll/scroll.gif" alt=""></p><p>html代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;syn-margin-left-24&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex;&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">nz-table</span> [<span class="hljs-attr">nzData</span>]=<span class="hljs-string">&quot;leftData&quot;</span>  [<span class="hljs-attr">nzScroll</span>]=<span class="hljs-string">&quot;&#123;y: &#x27;300px&#x27;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 95%;&quot;</span> [<span class="hljs-attr">nzShowPagination</span>]=<span class="hljs-string">false</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> &gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> &gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> &gt;</span>Address<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let data of leftData&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.age</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">nz-table</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">nz-table</span> [<span class="hljs-attr">nzData</span>]=<span class="hljs-string">&quot;rightData&quot;</span> [<span class="hljs-attr">nzScroll</span>]=<span class="hljs-string">&quot;&#123;y: &#x27;300px&#x27;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 95%;&quot;</span> [<span class="hljs-attr">nzShowPagination</span>]=<span class="hljs-string">false</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Address<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let data of rightData&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.age</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">nz-table</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>ts代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; StorageUtil &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../shared/utils/storage-util&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; AfterViewInit, Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  name?: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>  address?: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-meta">@Component</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-dashboard&#x27;</span>,<br>  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./dashboard.component.html&#x27;</span>,<br>  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;./dashboard.component.scss&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">AfterViewInit</span> </span>&#123;<br>  <span class="hljs-attr">leftData</span>: Person[] = <span class="hljs-built_in">this</span>.generateItems(<span class="hljs-string">&#x27;Edward King&#x27;</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;London, Park Lane no.&#x27;</span>,<span class="hljs-number">25</span>);<br>  rightData: Person[] = <span class="hljs-built_in">this</span>.generateItems(<span class="hljs-string">&#x27;John Brown&#x27;</span>,<span class="hljs-number">42</span>,<span class="hljs-string">&#x27;New York No. 1 Lake Park&#x27;</span>,<span class="hljs-number">15</span>);<br>  ngAfterViewInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.ant-table-body&#x27;</span>);<br>    <span class="hljs-keyword">const</span> leftTable = element[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> rightTable = element[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> scale = (leftTable.scrollHeight - leftTable.clientHeight) / (rightTable.scrollHeight - rightTable.clientHeight);<br>    <span class="hljs-keyword">if</span> (leftTable?.scrollHeight &amp;&amp; leftTable.clientHeight &amp;&amp; leftTable?.scrollHeight &amp;&amp; leftTable.clientHeight) &#123;<br>      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>      leftTable.addEventListener(<span class="hljs-string">&#x27;mouseover&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        leftTable.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (!flag) &#123;<br>            rightTable.scrollTop = leftTable.scrollTop / scale;<br>            rightTable.scrollLeft = leftTable.scrollLeft;<br>          &#125;<br>        &#125;)<br>      &#125;);<br>      rightTable.addEventListener(<span class="hljs-string">&#x27;mouseover&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        rightTable.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (flag) &#123;<br>            leftTable.scrollTop = rightTable.scrollTop * scale;<br>            leftTable.scrollLeft = rightTable.scrollLeft;<br>          &#125;<br>        &#125;)<br>      &#125;);<br>    &#125;<br>  &#125;<br>  generateItems(name: <span class="hljs-built_in">string</span>,<span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span>,<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>): Person[] &#123;<br>    <span class="hljs-keyword">const</span> res: Person[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      res.push(<br>        &#123;<br>         <span class="hljs-attr">name</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span><span class="hljs-subst">$&#123;i&#125;</span>`</span>,<br>         <span class="hljs-attr">age</span>: age + i,<br>         <span class="hljs-attr">address</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;address&#125;</span><span class="hljs-subst">$&#123;i&#125;</span>`</span><br>        &#125;<br>      )<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看ts代码的第23行，querySelectAll()方法可以获取所有class名为&quot;ant-table-body&quot;的元素，这个class是ng-zorro框架内部的类，可以通过浏览器的审查元素看到：</p><p><img src="/img/ng-zorro-scroll/ng-zorro-scroll-1.png" alt=""></p><p>可能你会有疑问为什么我会找这个class呢？这是因为我们要监听存在滚动条的容器的scroll事件，所以自然的要找到这个容器。</p><p>现在已经把Dom找出来了，下一步就是设置让两个table的scrollTop和scrollLeft的值相同即可。</p><p>有两个需要注意的地方：</p><ol><li><p>上面的代码我们设置了个flag值，是为了防止左右两个table相互赋值导致滑动缓慢，同时也可减少浏览器的性能消耗，你可以去掉flag字段看看，滑动会变卡。</p></li><li><p>scale值是为了防止两个table的高度不一样设置的，这样的话滑动的时候两个table会同时到达底部或顶部。如果两个table的高度相同那scale就没啥意义了，加不加都一样。</p></li></ol><p>完整的思路如下：</p><ol><li><p>找到关键点，使两个table同步滚动的关键就是找到并设置两个table滚动区域的scrollTop、scrollLeft的值相同即可。</p></li><li><p>因为用的是ng-zorro框架，所以通过审查元素定位到某个div。</p></li><li><p>通过querySelectorAll()方法获取两个table的dom对象，获取dom对象的方式有很多种，在这里只能用querySelectorAll()方法。</p></li><li><p>添加监听事件，先监听mouseover再监听scroll事件。</p></li><li><p>设置两个容器的scrollTop和scrollLeft的值相同。</p></li><li><p>考虑反思有没有问题，比如两个table高度不一样等，然后再想怎么完善。</p></li></ol><p>解决该问题用到了很多基础的js的知识，比如原生的鼠标监听事件，mouseover、scroll等，还有scrollTop、scrollHeigh、clientHeight等属性的理解，由此看出有一个好的基础还是挺重要的！</p><p>以上。笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>ng-zorro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中的repeat函数的用法</title>
    <link href="/posts/ad542c12/"/>
    <url>/posts/ad542c12/</url>
    
    <content type="html"><![CDATA[<p>在学习css的过程中发现css是真的难，可能某一个属性就得去深究半天，不积跬步无以至千里，遇到不会的且觉着有深度的问题尽量学习记录一下吧。今天来看一下css中的repeat()函数。</p><span id="more"></span><h3 id="定义">定义</h3><p>先看MDN的定义吧：</p><blockquote><p>CSS repeat() 函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows.</p></blockquote><p>我个人的理解: grid布局中grid-template-columns 和 grid-template-rows 两个属性分别是定义网格的列数和行数，如果定义大量的重复宽度的行或列就可以用到这个函数简化了，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br><br>// 等同于<br><br>grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>,<span class="hljs-number">100px</span>);<br></code></pre></td></tr></table></figure><h3 id="取值">取值</h3><p>定义其实不难，重点是它的语法和使用，尤其是当它与关键字结合时会有意想不到的效果。</p><p>repeat函数所有的取值如下：</p><ol><li><p>正整数长度。如 100px、10vw等</p></li><li><p>百分比，相对于网格容器块的大小的百分比。如 10%</p></li><li><p>带有 fr 单位的非负尺寸指定轨道的弹性系数。 如 1fr</p></li><li><p>max-content 关键字，代表占据网格轨道的网格项目所分配的最大内容区域的最大值。</p></li><li><p>min-content 关键字，代表占据网格轨道的网格项目所分配的最小内容区域的最小值。</p></li><li><p>auto 关键字，作为最大值，等同于 max-content。作为最小值，它代表占据网格轨道的网格项目的最小尺寸的最大值 （如同min-width/min-height所指定的)）。</p></li><li><p>auto-fill 关键字，内容自动填充，具体解释和下面的auto-fit关键字一起说。</p></li><li><p>auto-fit 关键词，内容自动适应。</p></li></ol><h3 id="Demo">Demo</h3><ol><li>网格划分成4列，比例为1:1:1:1</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repeat</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><p><img src="/img/repeat/repeat-demo-1.png" alt=""></p><p><a href="https://codepen.io/yanglusen/pen/PoJXdgj">Demo传送门</a></p><ol start="2"><li>使用关键字 min-content/max-content</li></ol><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>,<span class="hljs-built_in">min</span>-content);<br><br><span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>,<span class="hljs-built_in">max</span>-content);<br></code></pre></td></tr></table></figure><p>1）先看min-content的代码和示例图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-containter&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>grid grid grid grid grid grid grid grid grid grid<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAAAAAAAAAAAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAAAAAAAAAAAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAAAA BBBBBB<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>cc<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>cc<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-containter</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50vw</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">220px</span>;<br>  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>,min-content);<br>  place-items: center;<br>  gap: <span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> transparent;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#F89427</span>;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例图：</p><p><img src="/img/repeat/repeat-demo-2.png" alt=""></p><p><a href="https://codepen.io/yanglusen/pen/YzrdJOE">Demo传送门</a></p><p><strong>对于min-content这个关键词我个人觉着是不太好理解的，如果看完代码和示例图有疑问的话可到文末看对于这个关键词的单独分析。</strong></p><p>2）再看max-content的代码和示例图</p><p>代码只需要改动css中的一行，把 min-content 替换成 max-content</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: repeat(<span class="hljs-number">4</span>,<span class="hljs-built_in">max</span>-<span class="hljs-built_in">content</span>);<br></code></pre></td></tr></table></figure><p>示例图</p><p><img src="/img/repeat/repeat-demo-2-2.png" alt=""></p><p>可以看到它们之间的区别，只有第一个div的宽度变大了，是因为此max-content取得是第一个p标签的宽度作为div的宽度。而min-content取得是最后一个p标签的宽度。</p><p>3.固定某列宽度，其它列按比例平分</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: <span class="hljs-number">400</span>px repeat(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><p><img src="/img/repeat/repeat-demo-3.png" alt=""></p><p><a href="https://codepen.io/yanglusen/pen/bGoOQLN">Demo传送门</a></p><ol start="4"><li>使用minmax函数，设置列的最大、最小值</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr));<br></code></pre></td></tr></table></figure><ol start="4"><li>使用关键字 auto-fill/auto-fit</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr));<br><br>grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr));<br></code></pre></td></tr></table></figure><p>auto-fill</p><p><img src="/img/repeat/repeat-demo-4.png" alt=""></p><p>auto-fit</p><p><img src="/img/repeat/repeat-demo-5.png" alt=""></p><p>auto-fill和auto-fit的区别从它们的名字上就能看出来，一个是自动填充，一个是自动适应，看一下国外大佬的解释：</p><blockquote><p>auto-fill: 填充尽可能多的列。因此，只要新列可以容纳，它就会创建隐式列，因为它试图用尽可能多的列填充行。新添加的列可以也可能是空的，但它们仍将占据行中的指定空间。</p></blockquote><blockquote><p>auto-fit: 适合当前可用列的空间扩大，以便他们占用任何可用的空间。浏览器在用额外的列填充这些额外的空间之后(如自动填充) ，然后折叠空的列。</p></blockquote><p><a href="https://codepen.io/yanglusen/pen/poWYPKq">Demo传送门</a></p><p><img src="/img/repeat/repeat-demo-4-1.png" alt=""></p><p>如上图：当容器空间充足时，auto-fill会隐式的创建更多的列。</p><h3 id="min-content关键词">min-content关键词</h3><p>为什么把min-content关键词单独拿出来说，我查了很多资料并没有很好的解释到位，而且我发现网上还有一些关于它的demo的理解是错误的，所以特此解释一下我的理解：</p><p>看MDN的解释：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The <span class="hljs-built_in">min</span>-content sizing keyword represents <span class="hljs-keyword">the</span> intrinsic minimum width <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> content. For <span class="hljs-keyword">text</span> content this means that <span class="hljs-keyword">the</span> content will take all soft-wrapping opportunities, becoming <span class="hljs-keyword">as</span> small <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> longest <span class="hljs-built_in">word</span>.<br></code></pre></td></tr></table></figure><p>这个是英文版的，为什么不看中文版的呢？因为中文版的内容没有及时更新，至少截止到我写这篇文章的时候是没有的。</p><p>大概的意思就是min-content 关键字表示内容固有的最小宽度，对于文本而言，最小宽度则是最长单词的宽度。懂了吗？如果一个容器内的内容是文本，如果用了min-content关键字，那么该容器的宽度则取容器内单词最长的文本的宽度，而不是单词最短的那个，这里还有一个坑就是，对于中文而言，一个字就是一个“词”，而对于英文和数字，则是根据空格来区分一个词的。比如 &quot;HelloWorld&quot;这是一个词。</p><p>再看上文中的例子就可以理解了吧？</p><p>以上，虽然文章标题是repeat函数，但是并不只是讲了repeat函数，笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p><p>参考资料：</p><p><a href="https://css-tricks.com/auto-sizing-columns-css-grid-auto-fill-vs-auto-fit/">Auto-Sizing Columns in CSS Grid: <code>auto-fill</code> vs <code>auto-fit</code></a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/min-content">MDN min-content</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>repeat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中的linear-gradient函数的用法</title>
    <link href="/posts/147173af/"/>
    <url>/posts/147173af/</url>
    
    <content type="html"><![CDATA[<p>日常工作中用到了渐变色，但是仅限于了解实现简单的效果，所以趁着有空好好学习一番。</p><span id="more"></span><h3 id="定义">定义</h3><p>MDN的解释：</p><blockquote><p>CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于&lt;gradient&gt;数据类型，是一种特别的&lt;image&gt;数据类型。</p></blockquote><p>linear-gradient其实就是相当于background-image，它创建的是背景图片而非背景色。</p><h4 id="渐变角度">渐变角度</h4><p>渐变角度是与渐变容器中心点的垂线形成的角度。</p><h4 id="渐变线">渐变线</h4><blockquote><p>渐变线由包含渐变图形的容器的中心点和一个角度来定义的。渐变线上的颜色值是由不同的点来定义，包括起始点，终点，以及两者之间的可选的中间点（中间点可以有多个）</p></blockquote><p>如下图：</p><p><img src="/img/linear-gradient/gradient-1.png" alt=""></p><p>点C为渐变容器的中心点，角度A是与过C点的垂线形成的角度，穿过中心点形成渐变角的这条线就叫做渐变角度。</p><p><strong>渐变线和渐变角度相辅相成，它们之间可以根据彼此互相计算得到。</strong></p><h4 id="起始点">起始点</h4><blockquote><p>起始点是渐变线上代表起始颜色值的点。起始点由渐变线和过容器顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内）</p></blockquote><h4 id="终点">终点</h4><blockquote><p>终点是渐变线上代表最终颜色值的点。终点也是由渐变线和从最近的顶点发出的垂直线之间的交叉点定义的，然而从起始点的对称点来定义终点是更容易理解的一种方式，因为终点是起点关于容器的中心点的反射点。</p></blockquote><p>如下图：</p><p><img src="/img/linear-gradient/gradient-2.png" alt=""></p><h3 id="语法">语法</h3><p>先看MDN：</p><p><img src="/img/linear-gradient/gradient-3.png" alt=""></p><blockquote><p><strong>&lt;side-or-corner&gt;</strong><br>描述渐变线的起始点位置。它包含to和两个关键词：第一个指出水平位置left or right，第二个指出垂直位置top or bottom。关键词的先后顺序无影响，且都是可选的。<br>to top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p></blockquote><blockquote><p><strong>&lt;angle&gt;</strong><br>用角度值指定渐变的方向（或角度）。角度顺时针增加。</p></blockquote><blockquote><p><strong>&lt;linear-color-stop&gt;</strong><br>由一个<color>值组成，并且跟随着一个可选的终点位置（可以是一个百分比值或者是沿着渐变轴的<length>）</p></blockquote><blockquote><p><strong>&lt;color-hint&gt;</strong><br>颜色中转点是一个插值提示，它定义了在相邻颜色之间渐变如何进行。长度定义了在两种颜色之间的哪个点停止渐变颜色应该达到颜色过渡的中点。如果省略，颜色转换的中点是两个颜色停止之间的中点。</p></blockquote><p>太多？看不懂？没关系：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Value_definition_syntax">教你读懂MDN上的CSS语法</a></p><p>简单的总结一下语法：</p><table><thead><tr><th>值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>方向</td><td style="text-align:center">定义渐变色的渐变方向（角度）,其值可选，默认值是180deg（to bottom）</td></tr><tr><td>渐变色</td><td style="text-align:center">至少由两个颜色组成，每个颜色后面跟着可选参数，表示两个颜色之间渐变色的起点，如：linear-gradient(red 10%, blue 90%)，表示从起点到10%的距离为红色，10%-90%的距离为从红色渐变到蓝色，90%-终点为蓝色。每两个颜色中间还有一个可选参数，代表两个颜色转换的中点，默认50%，如10% - 90% 这段渐变距离的中点就是两个颜色的转换的中点</td></tr></tbody></table><h3 id="Demo">Demo</h3><p>列举该函数所有可能性的用法：</p><ol><li>第一个参数不写,默认180deg，从上到下渐变</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">background</span>: linear-gradient(<span class="hljs-built_in">red</span>, <span class="hljs-built_in">blue</span>);<br><br><span class="hljs-comment">// 等同于：</span><br><br><span class="hljs-built_in">background</span>: linear-gradient(<span class="hljs-number">180</span>deg, <span class="hljs-built_in">red</span>, <span class="hljs-built_in">blue</span>);<br><br><span class="hljs-built_in">background</span>: linear-gradient(to bottom, <span class="hljs-built_in">red</span>, <span class="hljs-built_in">blue</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-4.png" alt=""></p><p><strong><a href="https://codepen.io/yanglusen/pen/yLzRpNR">Demo传送门</a></strong></p><ol start="2"><li>带第一个参数，45度渐变</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, red, blue);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-5.png" alt=""></p><p><strong><a href="https://codepen.io/yanglusen/pen/MWEPrgP">Demo传送门</a></strong></p><ol start="3"><li>渐变色后跟可选参数，表示渐变的距离</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(red <span class="hljs-number">20%</span>, blue <span class="hljs-number">80%</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-6.png" alt=""></p><p><strong><a href="https://codepen.io/yanglusen/pen/eYGPymx">Demo传送门</a></strong></p><ol start="4"><li>每两个渐变色之间跟可选参数，表示两个颜色间渐变的中心点</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">background</span>: linear-gradient(red <span class="hljs-number">20</span>%, <span class="hljs-number">60</span>%, blue <span class="hljs-number">80</span>%);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-7.png" alt=""></p><p><strong><a href="https://codepen.io/yanglusen/pen/MWEPOLB">Demo传送门</a></strong></p><p>再解释一下，渐变中心：从上到下，20%到80%为容器的渐变距离，然后如果不设置渐变中心，默认50%，也就是说20%到80%之间距离的中心也就是两个颜色正式改变的位置，如上，我设置了渐变中心为60%的位置，也就是说红色渐变的距离长，颜色改变的慢。</p><p>以上。笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p><p>参考资料：</p><p><a href="https://www.w3cplus.com/css3/do-you-really-understand-css-linear-gradients.html">你真的理解CSS的linear-gradient？</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/linear-gradient()">MDN—CSS linear-gradient()函数</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>linear-gradient</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
