<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录一次使用Rxjs的Operators优化消息搜索功能</title>
    <link href="/2022/08/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Rxjs%E7%9A%84Operators%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/08/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Rxjs%E7%9A%84Operators%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在开发消息搜索模块时，遇到个问题：如果在防抖允许的时间内，连续两次输入不同的关键词触发http请求，如果网络速度慢，或者接口调用时间长的话，就会导致两个http连接同时在请求，这样就会导致页面会显示两遍不同的请求结果，甚至如果说第一次的请求响应时间快于第二次的话，会造成当搜索的结果显示不正确的现象。当时并没有想到好的解决思路，然后就搁置了，直到最近看到一篇文章，正好解决了我的需求，然后就来优化记录一下。</p><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><p>先看一下之前的代码：</p><p><img src="/img/optimize-message/precode.png"></p><p>其中主要的问题就是订阅层层嵌套，看起来非常乱，也没有一些搜索的优化。</p><p>利用rxjs操作符优化后的代码：</p><p><img src="/img/optimize-message/curcode.png"></p><p>可以明显的看出来代码变得简洁了许多。</p><p>主要的操作符如下：</p><ul><li><p>forkJoin</p></li><li><p>fromEvent</p></li><li><p>map</p></li><li><p>filter</p></li><li><p>debounceTime</p></li><li><p>distinctUntilChanged</p></li><li><p>switchMap</p></li><li><p>takeUntil</p></li></ul><p>分析：</p><p>首先使用forkJoin来聚合三个Observable，避免了订阅的层层嵌套，使用fromEvent操作符替代input的keyup事件，map操作符处理流发出输入的值，filter过滤掉空字符串，不会发送请求，debounceTime进行防抖处理，用户可以键入一个值，按退格键并再次键入，这可能会导致重复的搜索值。 我们可以通过添加 distinctUntilChanged 操作符来防止重复搜索的发生。switchMap操作符的作用是如果连续发送了两次请求，且都没有请求完成，则可以取消之前的搜索。最后使用takeUnit操作符来管理取消订阅。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>rxjs操作符的合理运用可以优化代码逻辑，但是rxjs操作符种类多，而且学起来多少的是有点抽象的，只有在实际的开发中去应用它，才更能体会到它的强大之处～Keep Learning～</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>operators</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular中的依赖注入</title>
    <link href="/2022/07/20/Angular%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/07/20/Angular%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信angular中的「依赖注入」对于大部分的angular开发者都是一个不容易跨过去的坎，当然我也不例外，这篇文章构思了很久，大概从一年前就想对此来个总结，奈何不知道从何写起，主要原因是在平常的实际开发中用到的依赖注入的知识太浅，所以并不能很好的读懂文档的意思，如今有机会在实际的项目中接触到了更多依赖注入的用法，故此总结一下。本文内容大部分来源于官方文档，因为文档中的知识点过于零散，东一锤子西一棒子的，摸不着头脑，所以我按照自己的理解，加上实际的demo来梳理一下其中的知识点。</p><h2 id="什么是「依赖注入（dependency-injection）」？"><a href="#什么是「依赖注入（dependency-injection）」？" class="headerlink" title="什么是「依赖注入（dependency injection）」？"></a>什么是「依赖注入（dependency injection）」？</h2><blockquote><p>依赖注入既是设计模式，同时又是一种机制：当应用程序的一些部件（即一些依赖）需要另一些部件时， 利用依赖注入来创建被请求的部件，并将它们注入到需要它们的部件中。<br>在 Angular 中，依赖通常是服务，但是也可以是值，比如字符串或函数。应用的注入器（它是在启动期间自动创建的）会使用该服务或值的配置好的提供者来按需实例化这些依赖。各个不同的提供者可以为同一个服务提供不同的实现。</p></blockquote><p>上面这段话用我自己的理解，通俗的来讲就是，之前我们如果想要实例化类（class）的一个对象，就要用「new」运算符来实现，现在有了依赖注入这个东西以后就不需要我们自己亲自动手去new一个对象了，我们只需要在用到的地方使用angular的「依赖注入」的语法，就可以拿到我们想要的对象了，而帮助我们创建对象的这个东西叫做「注入器」，注入器这个东西，很抽象，我们看不见摸不着，这是angular在运行过程中帮助我们自动创建的。</p><p>先把几个名词搞清楚，「服务」、「注入器」、「DI令牌」、「提供者」。</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>在 Angular 中，服务就是一个带有 @Injectable 装饰器的类，它封装了可以在应用程序中复用的非 UI 逻辑和代码。 Angular 把组件和服务分开，是为了增进模块化程度和可复用性。</p><p>@Injectable 元数据让服务类能用于依赖注入机制中。可注入的类是用提供者进行实例化的。 各个注入器会维护一个提供者的列表，并根据组件或其它服务的需要，用它们来提供服务的实例。</p><h2 id="DI令牌"><a href="#DI令牌" class="headerlink" title="DI令牌"></a>DI令牌</h2><p>一种用来查阅的令牌，它关联到一个依赖提供者，用于依赖注入系统中，DI令牌和注入的依赖项相映射，可以把DI令牌作为key来找到依赖项。</p><p>令牌通常是 Type 或 InjectionToken 的实例，但也可以是 any 实例。</p><h2 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h2><p>一个实现了 Provider 接口的对象。一个提供者对象定义了如何获取与 DI 令牌（token） 相关联的可注入依赖。 注入器会使用这个提供者来创建它所依赖的那些类的实例。</p><p>Angular 会为每个注入器注册一些 Angular 自己的服务。你也可以注册应用自己所需的服务提供者。</p><p>依赖提供者会使用 DI 令牌来配置注入器，注入器会用它来提供这个依赖值的具体的、运行时版本。</p><figure class="highlight coq"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs coq">type Provider = TypeProvider | <span class="hljs-type">ValueProvider</span> | <span class="hljs-type">ClassProvider</span> | <span class="hljs-type">ConstructorProvider</span> | <span class="hljs-type">ExistingProvider</span> | <span class="hljs-type">FactoryProvider</span> | <span class="hljs-type">any</span>[];<br></code></pre></td></tr></table></figure><p>ClassProvider</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">ClassProvider</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">ClassSansProvider</span> &#123;<br>  <span class="hljs-comment">// DI 令牌</span><br>  provide: any<br>  multi?: <span class="hljs-built_in">bool</span>ean<br><br>  <span class="hljs-comment">// 继承自 core/ClassSansProvider</span><br>  useClass: Type&lt;any&gt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h2><p>Angular 依赖注入系统中可以在缓存中根据名字查找依赖，也可以通过配置过的「提供者」来创建依赖。 启动过程中会自动为每个模块创建一个注入器，并被组件树继承。</p><ul><li><p>注入器会提供依赖的一个单例，并把这个单例对象注入到多个组件中。</p></li><li><p>模块和组件级别的注入器树可以为它们拥有的组件及其子组件提供同一个依赖的不同实例。</p></li><li><p>你可以为同一个依赖使用不同的提供者来配置这些注入器，这些提供者可以为同一个依赖提供不同的实现。</p></li></ul><h2 id="怎么注入一个依赖？"><a href="#怎么注入一个依赖？" class="headerlink" title="怎么注入一个依赖？"></a>怎么注入一个依赖？</h2><p>以最常用的服务为例，在组件中注入一个服务：</p><p>上面👆介绍了，在 Angular 中服务就是一个带有 @Injectable() 装饰器的类，可以把它作为依赖，注入到组件中。同样，也要使用 @Injectable() 装饰器来表明一个组件或其它类（比如另一个服务、管道或 NgModule）拥有一个依赖，我们实际项目中绝大部分注入的依赖都是服务。</p><ul><li><p><strong>注入器</strong>是主要的机制。Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建「注入器」。</p></li><li><p>该注入器会创建依赖、维护一个容器来管理这些依赖，并尽可能复用它们。</p></li><li><p><strong>提供者</strong>是一个对象，用来告诉注入器应该如何获取或创建依赖。</p></li></ul><p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个<strong>提供者</strong>，以便注入器可以使用这个提供者来创建新实例。对于服务，该提供者通常就是服务类本身。</p><blockquote><p>依赖不一定是服务 —— 它还可能是函数或值。</p></blockquote><p>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。如下：HeroListComponent 的构造函数中需要 HeroService</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> service: HeroService)</span> <span class="hljs-comment">&#123; &#125;</span></span><br></code></pre></td></tr></table></figure><p>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在实例，注入器就会使用以前注册的服务提供者来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p><p>当所有请求的服务已解析并返回时，Angular 可以用这些服务实例为参数，调用该组件的构造函数。</p><p>注入过程可以用下方非常形象和经典的一张图来概括：</p><p><img src="/img/inject/injector-injects.png"></p><p>个人理解：图中的Injector就是注入器，它管理着很多的依赖，Angular中「依赖项」和「DI令牌」相映射，「DI令牌」作为映射的key，「依赖项」作为映射的value，当发现构造函数中依赖HeroService时，注入器就会把HeroService当作「DI令牌」去注入器中去查找相应的「依赖项」，找到依赖项以后，然后再去查找该依赖有没有已经实例化好的对象，如果有就直接返回该对象，如果没有，注入器就会根据该依赖的「提供者」去创建对象，所以说对象是由注入器根据提供者创建的。「服务」的「提供者定义对象」默认就是 useClass，也就是说注入器会通过 new 的方式创建一个对象，此外「提供者定义对象」还可以是 useValue 、useExisting、useFactory等。</p><h2 id="提供服务的三种方式"><a href="#提供服务的三种方式" class="headerlink" title="提供服务的三种方式"></a>提供服务的三种方式</h2><p>对于要用到的任何服务，你必须至少注册一个提供者。服务可以在自己的元数据中把自己注册为提供者，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供者。要注册提供者，就要在服务的 @Injectable() 装饰器中提供它的元数据，或者在 @NgModule() 或 @Component() 的元数据中。</p><ol><li>默认情况下，Angular CLI 的 ng generate service 命令会在 @Injectable() 装饰器中提供元数据来把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供者：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@Injectable</span>(&#123;<br> providedIn: <span class="hljs-string">&#x27;root&#x27;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。这种在 @Injectable 元数据中注册提供者的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小。</p><ol start="2"><li>当你使用特定的 NgModule 注册提供者时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 @NgModule() 装饰器中的 providers 属性：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@NgModule</span>(&#123;<br>  providers: [<br>  BackendService,<br>  Logger<br> ],<br> …<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>当你在组件级注册提供者时，你会为该组件的每一个新实例提供该服务的一个新实例。要在组件级注册，就要在 @Component() 元数据的 providers 属性中注册服务提供者。</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span>(&#123;<br>  <span class="hljs-attribute">selector</span>:    <span class="hljs-string">&#x27;app-hero-list&#x27;</span>,<br>  <span class="hljs-attribute">templateUrl</span>: <span class="hljs-string">&#x27;./hero-list.component.html&#x27;</span>,<br>  <span class="hljs-attribute">providers</span>:  [ HeroService ]<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="定义提供者"><a href="#定义提供者" class="headerlink" title="定义提供者"></a>定义提供者</h2><h3 id="类提供者"><a href="#类提供者" class="headerlink" title="类提供者"></a>类提供者</h3><p>类提供者的语法实际上是一种简写形式，它会扩展成一个由 Provider 接口定义的提供者配置对象。下面的代码片段展示了 providers 中给出的类会如何扩展成完整的提供者配置对象。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">providers</span>:<span class="hljs-meta"> [Logger]</span><br></code></pre></td></tr></table></figure><p>Angular 把这个 providers 值扩展为一个完整的提供者对象，如下所示。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[&#123; provide: Logger, useClass: Logger &#125;]<br></code></pre></td></tr></table></figure><p>扩展的提供者配置是一个具有两个属性的对象字面量：</p><ul><li><p>provide 属性存有令牌，它作为一个 key，在定位依赖值和配置注入器时使用。</p></li><li><p>第二个属性是一个提供者定义对象，它告诉注入器要如何创建依赖值。提供者定义对象中的 key 可以是 useClass —— 就像这个例子中一样。也可以是 useExisting、useValue 或 useFactory。每一个 key 都用于提供一种不同类型的依赖，我们稍后会讨论。</p></li></ul><h2 id="别名类提供者"><a href="#别名类提供者" class="headerlink" title="别名类提供者"></a>别名类提供者</h2><p>要为类提供者设置别名，请在 providers 数组中使用 useExisting 属性指定别名和类提供者。</p><p>在下面的例子中，当组件请求新的或旧的记录器时，注入器都会注入一个 NewLogger 的实例。通过这种方式，OldLogger 就成了 NewLogger 的别名。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">[ NewLogger,<br>  <span class="hljs-regexp">//</span> Alias OldLogger w/ reference to NewLogger<br>  &#123; provide: OldLogger, useExisting: NewLogger&#125;]<br></code></pre></td></tr></table></figure><p>请确保你没有使用 useClass 来把 OldLogger 设为 NewLogger 的别名，因为如果这样做它就会创建两个不同的 NewLogger 实例。</p><h2 id="注入一个配置对象"><a href="#注入一个配置对象" class="headerlink" title="注入一个配置对象"></a>注入一个配置对象</h2><p>常用的对象字面量是配置对象。下列配置对象包括应用的标题和 Web API 的端点地址。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HERO_DI_CONFIG: AppConfig = &#123;<br>  apiEndpoint: <span class="hljs-string">&#x27;api.heroes.com&#x27;</span>,<br>  title: <span class="hljs-string">&#x27;Dependency Injection&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>定义和使用一个 InjectionToken 对象来为非类的依赖选择一个提供者令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; InjectionToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> APP_CONFIG = <span class="hljs-keyword">new</span> InjectionToken&lt;AppConfig&gt;(<span class="hljs-string">&#x27;app.config&#x27;</span>);<br></code></pre></td></tr></table></figure><p>接着，用 APP_CONFIG 这个 InjectionToken 对象在组件中注册依赖提供者。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">providers:</span> [&#123; <span class="hljs-attr">provide:</span> <span class="hljs-string">APP_CONFIG</span>, <span class="hljs-attr">useValue:</span> <span class="hljs-string">HERO_DI_CONFIG</span> &#125;]<br></code></pre></td></tr></table></figure><p>现在，借助参数装饰器 @Inject()，你可以把这个配置对象注入到构造函数中。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(@Inject(APP_CONFIG)</span> <span class="hljs-title">config</span>:</span> AppConfig) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  this.title = config.title;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="接口和依赖注入"><a href="#接口和依赖注入" class="headerlink" title="接口和依赖注入"></a>接口和依赖注入</h2><p>虽然 TypeScript 的 AppConfig 接口可以在类中提供类型支持，但它在依赖注入时却没有任何作用。在 TypeScript 中，接口是一项设计期工件，它没有可供 DI 框架使用的运行时表示形式或令牌。</p><p>当转译器把 TypeScript 转换成 JavaScript 时，接口就会消失，因为 JavaScript 没有接口。</p><p>由于 Angular 在运行期没有接口，所以该接口不能作为令牌，也不能注入它。</p><h2 id="使用工厂提供者"><a href="#使用工厂提供者" class="headerlink" title="使用工厂提供者"></a>使用工厂提供者</h2><p>要想根据运行前尚不可用的信息创建可变的依赖值，可以使用工厂提供者。</p><p>在下面的例子中，只有授权用户才能看到 HeroService 中的秘密英雄。授权可能在单个应用会话期间发生变化，比如改用其他用户登录。</p><p>要想在 UserService 和 HeroService 中保存敏感信息，就要给 HeroService 的构造函数传一个逻辑标志来控制秘密英雄的显示。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">private</span> logger: Logger,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">private</span> isAuthorized: <span class="hljs-built_in">boolean</span></span>)</span> &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-title">getHeroes</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> auth = <span class="hljs-built_in">this</span>.isAuthorized ? <span class="hljs-string">&#x27;authorized &#x27;</span> : <span class="hljs-string">&#x27;unauthorized&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.logger.log(<span class="hljs-string">`Getting heroes for <span class="hljs-subst">$&#123;auth&#125;</span> user.`</span>);<br>  <span class="hljs-keyword">return</span> HEROES.filter(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> <span class="hljs-built_in">this</span>.isAuthorized || !hero.isSecret);<br>&#125;<br></code></pre></td></tr></table></figure><p>要实现 isAuthorized 标志，可以用工厂提供者来为 HeroService 创建一个新的 logger 实例。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const heroServiceFactory =<span class="hljs-function"> (<span class="hljs-params">logger</span>: L<span class="hljs-params">ogger</span>, <span class="hljs-params">userService</span>: U<span class="hljs-params">serService</span>) =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-constructor">HeroService(<span class="hljs-params">logger</span>, <span class="hljs-params">userService</span>.<span class="hljs-params">user</span>.<span class="hljs-params">isAuthorized</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个工厂函数可以访问 UserService。你可以同时把 Logger 和 UserService 注入到工厂提供者中，这样注入器就可以把它们传给工厂函数了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">export</span> <span class="hljs-string">const</span> <span class="hljs-string">heroServiceProvider</span> <span class="hljs-string">=</span><br>  &#123; <span class="hljs-attr">provide:</span> <span class="hljs-string">HeroService</span>,<br>    <span class="hljs-attr">useFactory:</span> <span class="hljs-string">heroServiceFactory</span>,<br>    <span class="hljs-attr">deps:</span> [<span class="hljs-string">Logger</span>, <span class="hljs-string">UserService</span>]<br>  &#125;<span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><ul><li><p>useFactory 字段指定该提供者是一个工厂函数，其实现代码是 heroServiceFactory</p></li><li><p>deps 属性是一个提供者令牌数组。Logger 和 UserService 类都是自己类提供者的令牌。该注入器解析了这些令牌，并把相应的服务注入到 heroServiceFactory 工厂函数的参数中。</p></li></ul><p>通过把工厂提供者导出为变量 heroServiceProvider，就能让工厂提供者变得可复用。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; heroServiceProvider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hero.service.provider&#x27;</span>;<br><br>@Component(&#123;<br>  selector: <span class="hljs-string">&#x27;app-heroes&#x27;</span>,<br>  providers: [ heroServiceProvider ],<br>  template: `<span class="javascript"></span><br><span class="javascript">    &lt;h2&gt;Heroes&lt;/h2&gt;</span><br><span class="javascript">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">app-hero-list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-hero-list</span>&gt;</span></span></span><br><span class="javascript">  </span>`<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> &#123; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="多级注入器"><a href="#多级注入器" class="headerlink" title="多级注入器"></a>多级注入器</h2><p>Angular 中有两个注入器层次结构：</p><ul><li><p>ModuleInjector 层次结构：使用 @NgModule() 或 @Injectable() 注解在此层次结构中配置 ModuleInjector。</p></li><li><p>ElementInjector 层次结构：在每个 DOM 元素上隐式创建。默认情况下，ElementInjector 是空的，除非你在 @Directive() 或 @Component() 的 providers 属性中配置它。</p></li></ul><h3 id="ModuleInjector"><a href="#ModuleInjector" class="headerlink" title="ModuleInjector"></a>ModuleInjector</h3><p>可以通过以下两种方式之一配置 ModuleInjector ：</p><ul><li><p>使用 @Injectable() 的 providedIn 属性引用 @NgModule() 或 root</p></li><li><p>使用 @NgModule() 的 providers 数组</p></li></ul><h4 id="摇树优化与-Injectable"><a href="#摇树优化与-Injectable" class="headerlink" title="摇树优化与 @Injectable()"></a>摇树优化与 @Injectable()</h4><blockquote><p>使用 @Injectable() 的 providedIn 属性优于 @NgModule() 的 providers 数组，因为使用 @Injectable() 的 providedIn 时，优化工具可以进行摇树优化，从而删除你的应用程序中未使用的服务，以减小捆绑包尺寸。摇树优化对于库特别有用，因为使用该库的应用程序不需要注入它。</p></blockquote><p>ModuleInjector 由 @NgModule.providers 和 NgModule.imports 属性配置。ModuleInjector 是可以通过 NgModule.imports 递归找到的所有 providers 数组的扁平化。</p><p>子 ModuleInjector 是在惰性加载其它 @NgModules 时创建的。</p><h4 id="平台注入器"><a href="#平台注入器" class="headerlink" title="平台注入器"></a>平台注入器</h4><p>在 root 之上还有两个注入器，一个是额外的 ModuleInjector，一个是 NullInjector()。</p><p>另一个额外的ModuleInjector这里不作赘述，感兴趣的可以去官网了解。</p><p>层次结构中的下一个父注入器是 NullInjector()，它是树的顶部。如果你在树中向上走了很远，以至于要在 NullInjector() 中寻找服务，那么除非使用 @Optional()，否则将收到错误消息，因为最终所有东西都将以 NullInjector() 结束并返回错误，或者对于 @Optional()，返回 null。</p><p>下图展示了前面各段落描述的 root ModuleInjector 及其父注入器之间的关系。</p><p><img src="/img/inject/injectors.svg"></p><h3 id="ElementInjector"><a href="#ElementInjector" class="headerlink" title="ElementInjector"></a>ElementInjector</h3><p>Angular 会为每个 DOM 元素隐式创建 ElementInjector。</p><p>可以用 @Component() 装饰器中的 providers 或 viewProviders 属性来配置 ElementInjector 以提供服务。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span>(&#123;<br>  …<br>  <span class="hljs-attribute">providers</span>: [&#123; <span class="hljs-attribute">provide</span>: ItemService, <span class="hljs-attribute">useValue</span>: &#123; <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;lamp&#x27;</span> &#125; &#125;]<br>&#125;)<br>export class TestComponent<br></code></pre></td></tr></table></figure><h3 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h3><p>当为组件/指令解析令牌时，Angular 分为两个阶段来解析它：</p><ol><li><p>针对 ElementInjector 层次结构（其父级）。</p></li><li><p>针对 ModuleInjector 层次结构（其父级）。</p></li></ol><p>当组件声明依赖项时，Angular 会尝试使用它自己的 ElementInjector 来满足该依赖。 如果组件的注入器缺少提供者，它将把请求传给其父组件的 ElementInjector。</p><p>这些请求将继续转发，直到 Angular 找到可以处理该请求的注入器或用完祖先 ElementInjector。</p><p>如果 Angular 在任何 ElementInjector 中都找不到提供者，它将返回到发起请求的元素，并在 ModuleInjector 层次结构中进行查找。如果 Angular 仍然找不到提供者，它将引发错误。</p><p>如果你已在不同级别注册了相同 DI 令牌的提供者，则 Angular 会用遇到的第一个来解析该依赖。比如，如果提供者已经在需要此服务的组件中本地注册了，则 Angular 不会再寻找同一服务的其它提供者。</p><h3 id="解析修饰符"><a href="#解析修饰符" class="headerlink" title="解析修饰符"></a>解析修饰符</h3><p>可以使用 @Optional()，@Self()，@SkipSelf() 和 @Host() 来修饰 Angular 的解析行为。从 @angular/core 导入它们，并在注入服务时在组件类构造函数中使用它们。</p><h4 id="修饰符的类型"><a href="#修饰符的类型" class="headerlink" title="修饰符的类型"></a>修饰符的类型</h4><p>解析修饰符分为三类：</p><ul><li><p>如果 Angular 找不到你要的东西该怎么办，用 @Optional()</p></li><li><p>从哪里开始寻找，用 @SkipSelf()</p></li><li><p>到哪里停止寻找，用 @Host() 和 @Self()</p></li></ul><p>默认情况下，Angular 始终从当前的 Injector 开始，并一直向上搜索。修饰符使你可以更改开始（默认是自己）或结束位置。</p><p>另外，你可以组合除 @Host() 和 @Self() 之外的所有修饰符，当然还有 @SkipSelf() 和 @Self()。</p><h4 id="Optional"><a href="#Optional" class="headerlink" title="@Optional()"></a>@Optional()</h4><p>@Optional() 允许 Angular 将你注入的服务视为可选服务。这样，如果无法在运行时解析它，Angular 只会将服务解析为 null，而不会抛出错误。在下面的范例中，服务 OptionalService 没有在 @NgModule() 或组件类中提供，所以它没有在应用中的任何地方。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">OptionalComponent</span> &#123;<br>  <span class="hljs-selector-tag">constructor</span>(<span class="hljs-variable">@Optional</span>() public optional?: OptionalService) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Self"><a href="#Self" class="headerlink" title="@Self()"></a>@Self()</h4><p>使用 @Self() 让 Angular 仅查看当前组件或指令的 ElementInjector。</p><p>@Self() 的一个好例子是要注入某个服务，但只有当该服务在当前宿主元素上可用时才行。为了避免这种情况下出错，请将 @Self() 与 @Optional() 结合使用。</p><h4 id="SkipSelf"><a href="#SkipSelf" class="headerlink" title="@SkipSelf()"></a>@SkipSelf()</h4><p>@SkipSelf() 与 @Self() 相反。使用 @SkipSelf()，Angular 在父 ElementInjector 中而不是当前 ElementInjector 中开始搜索服务。</p><h4 id="Host"><a href="#Host" class="headerlink" title="@Host()"></a>@Host()</h4><p>@Host() 使你可以在搜索提供者时将当前组件指定为注入器树的最后一站。即使树的更上级有一个服务实例，Angular 也不会继续寻找。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>由于angular的依赖注入知识体系实在是过于庞大，本文也仅仅是了解了下它的基础用法，但是掌握了这些也足够我们在平常的开发中使用了，当然只学习用法和真正实践还是有很大区别的，有机会还是要多实践，除此之外angular还有很多依赖注入的高级实践，等以后有机会学习实践以后会再来补充文章。最后，angular官网文档yyds！</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>依赖注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react学习笔记-基础语法</title>
    <link href="/2022/03/29/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/03/29/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>由于ng写的枯燥无味，所以便趁着晚上无聊时间学习react，卷死你们！</p><p>此笔记是记录学习react的第一篇文章，主要学到了创建react组件的方式、jsx的基础语法以及react中的this指向问题。</p><h3 id="创建react组件的方式"><a href="#创建react组件的方式" class="headerlink" title="创建react组件的方式"></a>创建react组件的方式</h3><p>有两种方式可以创建组件：函数式组件和类组件。如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 函数式</span><br>function <span class="hljs-type">Welcome</span>(props) &#123;<br>  <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span>, &#123;props.name&#125;&lt;/h1&gt;;<br>&#125;<br><br><span class="hljs-comment">// 类组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span>, &#123;<span class="hljs-keyword">this</span>.props.name&#125;&lt;/h1&gt;;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在不考虑hooks之前，类组件就是比函数组件多了state（状态）功能，适合复杂功能，当然hooks就等以后学到再说吧。</p><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>在react中使用jsx来构建界面，最终由babel编译器转为普通的js代码。</p><p>JSX全称是JavaScript XML 是对JavaScript的一种扩展。下面是几种语法：</p><ol><li><p>定义虚拟dom时，不要写引号。</p></li><li><p>标签中混入js表达式时要用{}。</p></li><li><p>样式的类名不要用class，要换成className。</p></li><li><p>内联样式，要用{{key: value}}的形式去写。</p></li><li><p>只能有一个根标签，且标签必须闭合。</p></li><li><p>标签首字母：如果是大写，则babel会以组件去解析，否则会以HTML标签去解析。</p></li><li><p>点击事件要写成 onClick={this.handleClick}的形式，onClick驼峰写法。</p></li></ol><h3 id="react中的this指向问题"><a href="#react中的this指向问题" class="headerlink" title="react中的this指向问题"></a>react中的this指向问题</h3><p>先看一下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">frameWork</span>: [<span class="hljs-string">&#x27;Angular&#x27;</span>,<span class="hljs-string">&#x27;React&#x27;</span>,<span class="hljs-string">&#x27;Vue&#x27;</span>]&#125;;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-keyword">return</span> (<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">main</span>&#x27;&#125;&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;fontSize:</span>&#x27;<span class="hljs-attr">25px</span>&#x27;,<span class="hljs-attr">fontWeight:</span> &#x27;<span class="hljs-attr">bold</span>&#x27;&#125;&#125;&gt;</span>前端三大框架<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">               &#123;this.state.frameWork.map((item,index) =&gt;</span><br><span class="xml">                   (<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">list</span>&#x27;&#125; <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>))&#125;</span><br><span class="xml">           <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   )<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 此处打印的this会是undefined！</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里打印的this的undefined的原因如下：</p><ol><li><p>在react中的点击事件并不是由组件类的实例直接调用的，而是由window调用的，上面的代码中的onClick是一个赋值语句，并没有运行handleClick方法，而是由window调用的，相当于 window.handleClick()</p></li><li><p>handleClick方法是类中的实例方法，在类的实例方法内部会默认启用’ use strict ‘严格模式，在严格模式下，方法内部的this就变成了undefined。</p></li></ol><p>知道了原因以后解决方法如下：</p><ol><li>利用bind方法，显示的改变this指向。在construct构造方法中加入：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里的this指的是组件类的实例对象</span><br><span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>利用ES6的箭头函数，箭头函数中是没有this的，内部的this是指它上一层的作用域中的this。</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 把函数改造成箭头函数<br><span class="hljs-function"> <span class="hljs-title">handleClick</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下用到的js的知识点：</p><ol><li><p>原型与原型链（类的继承）</p></li><li><p>this的指向问题（箭头函数中的this）</p></li><li><p>js中的严格模式</p></li><li><p>显式改变this的指向的方法（bind、call、apply的区别）</p></li></ol><p>以上。由于笔者水平有限，若有错误敬请指正，欢迎评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>react基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angular中防抖的实现</title>
    <link href="/2022/02/21/angular%E4%B8%AD%E9%98%B2%E6%8A%96%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/21/angular%E4%B8%AD%E9%98%B2%E6%8A%96%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在angular中的防抖主要是利用了rxjs中的debounce操作符，非常简洁方便！下面主要是介绍其三种写法，主要分为两类，不封装指令的防抖和封装成指令的防抖，其中封装成指令的防抖又有两种写法：利用@HostListener装饰器和Renderer2.listen方法。</p><h3 id="不封装指令的防抖"><a href="#不封装指令的防抖" class="headerlink" title="不封装指令的防抖"></a>不封装指令的防抖</h3><p>html</p><figure class="highlight handlebars"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;syn-margin-24&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    默认时间500ms，只有500ms以内没有事件触发才会执行。</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;syn-margin-24 label-font&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">total</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">nz-button</span> <span class="hljs-attr">nzType</span>=<span class="hljs-string">&quot;primary&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;add($event)&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> <span class="hljs-attr">nzType</span>=<span class="hljs-string">&quot;plus&quot;</span> <span class="hljs-attr">nzTheme</span>=<span class="hljs-string">&quot;outline&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="xml">    Add</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; debounceTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Component,OnDestroy&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Subscription, Subject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;syn-debounce&#x27;</span>,<br>  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./debounce.component.html&#x27;</span>,<br>  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;./debounce.component.scss&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebounceComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span></span>&#123;<br>  <span class="hljs-keyword">public</span> total: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">public</span> debounceTime: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;<br>  <span class="hljs-keyword">public</span> subscription = <span class="hljs-keyword">new</span> Subscription();<br>  <span class="hljs-keyword">public</span> subject$ = <span class="hljs-keyword">new</span> Subject();<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.subject$.pipe(debounceTime(<span class="hljs-built_in">this</span>.debounceTime)).subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">this</span>.total+=<span class="hljs-number">1</span>);<br>   &#125;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">$event: MouseEvent</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subject$.next($event);<br>  &#125;<br>  ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription.unsubscribe();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="/img/debounce/article-1.gif"></p><p>定义了一个“主体”Subject，它既是观察者，也可以是订阅者，每次点击事件时调用add方法，然后使用next方法发送事件，然后由于subject$同时subscribe(订阅)了事件，所以会经过rxjs的debounce运算符的处理，其接收一个number类型的值，单位ms，就是我们设置的防抖时间。</p><h3 id="指令-HostListener"><a href="#指令-HostListener" class="headerlink" title="指令-@HostListener"></a>指令-@HostListener</h3><p>在实际的项目中用到防抖的地方肯定不只有一处，所以此时我们应该封装出一个防抖的指令使用,在ng中监听dom事件的方法我所了解的有两种：@HostListener监听和Renderer2.listen方法。思路都是一样的，都是利用了rxjs，只不过就是监听元素事件的写法不同而已。</p><p>ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Directive, EventEmitter, HostListener, Input, OnDestroy, OnInit, Output &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Subject, Subscription &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; debounceTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>基于rxjs的debounceTime操作符的防抖</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Directive</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;[synDebounceClick]&#x27;</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebounceClickDirective</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span>, <span class="hljs-title">OnDestroy</span> </span>&#123;<br>  <span class="hljs-meta">@Input</span>() debounceTime = <span class="hljs-number">500</span>;<br>  <span class="hljs-meta">@Output</span>(<span class="hljs-string">&#x27;synDebounceClick&#x27;</span>) debounceClick = <span class="hljs-keyword">new</span> EventEmitter();<br>  <span class="hljs-keyword">private</span> subject$ = <span class="hljs-keyword">new</span> Subject();<br>  <span class="hljs-keyword">private</span> subscription!: Subscription;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.subject$.pipe(<br>      debounceTime(<span class="hljs-built_in">this</span>.debounceTime)<br>    ).subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">this</span>.debounceClick.emit(e))<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">ngOnDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription.unsubscribe();<br>  &#125;<br>  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,[<span class="hljs-string">&#x27;$event&#x27;</span>])<br>  <span class="hljs-function"><span class="hljs-title">clickEvent</span>(<span class="hljs-params">event: <span class="hljs-built_in">any</span></span>)</span> &#123;<br>    event.preventDefault();<br>    event.stopPropagation();<br>    <span class="hljs-built_in">this</span>.subject$.next(event);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>导入相应的module后然后在HTML模板中使用即可</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> nz-<span class="hljs-keyword">button</span> nzType=<span class="hljs-string">&quot;primary&quot;</span> (synDebounceClick)=<span class="hljs-string">&quot;add()&quot;</span>&gt;Primary <span class="hljs-keyword">Button</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="指令-Renderer2-listen"><a href="#指令-Renderer2-listen" class="headerlink" title="指令-Renderer2.listen"></a>指令-Renderer2.listen</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; debounceTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Subject, Subscription &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Directive, ElementRef, Renderer2, OnInit, Input, Output, EventEmitter, OnDestroy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-meta">@Directive</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;[synDebounceRendererClick]&#x27;</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebounceRendererDirective</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span>, <span class="hljs-title">OnDestroy</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> subject$ = <span class="hljs-keyword">new</span> Subject();<br>  <span class="hljs-keyword">private</span> subscription!: Subscription;<br>  <span class="hljs-meta">@Input</span>() debounceTime: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;<br>  <span class="hljs-meta">@Output</span>(<span class="hljs-string">&#x27;synDebounceRendererClick&#x27;</span>) synDebounceRendererClick = <span class="hljs-keyword">new</span> EventEmitter();<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> _elementRef: ElementRef, <span class="hljs-keyword">private</span> _renderer2: Renderer2</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription = <span class="hljs-built_in">this</span>.subject$.pipe(debounceTime(<span class="hljs-built_in">this</span>.debounceTime))<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">this</span>.synDebounceRendererClick.emit());<br>  &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>._renderer2.listen(<span class="hljs-built_in">this</span>._elementRef.nativeElement,<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      e.stopPropagation();<br>      e.preventDefault();<br>      <span class="hljs-built_in">this</span>.subject$.next(e);<br>    &#125;);<br>  &#125;<br>  ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.subscription.unsubscribe();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>html</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> nz-<span class="hljs-keyword">button</span> nzType=<span class="hljs-string">&quot;primary&quot;</span> (synDebounceRendererClick)=<span class="hljs-string">&quot;add()&quot;</span>&gt;Primary <span class="hljs-keyword">Button</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>以上就是我所知道的三种写法，至于@HostListener和Renderer2.listen()有什么区别我也不是很清楚多方查阅也没有得到具体的结果，我所了解的是@HostListener只能监听宿主元素，而Renderer2.listen()可以监听任意元素，如果还有其它不同请在评论区留言交流！</p><p>笔者水平有限，若有错误敬请指正，不明白的地方欢迎评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>防抖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在js中计算字符串的像素长度</title>
    <link href="/2022/02/10/javascript%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6/"/>
    <url>/2022/02/10/javascript%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>关键点：利用Element.getBoundingClientRect()函数</p><h3 id="Element-getBoundingClientRect-介绍"><a href="#Element-getBoundingClientRect-介绍" class="headerlink" title="Element.getBoundingClientRect() 介绍"></a>Element.getBoundingClientRect() 介绍</h3><p>看一下mdn的解释：</p><blockquote><p>The Element.getBoundingClientRect() method returns a DOMRect object providing information about the size of an element and its position relative to the viewport.</p></blockquote><p>说的是这个函数会返回一个DOMRect对象，这个对象中会包含当前dom元素的一些信息，如相对于视窗的位置、宽高等。</p><p>需要注意的是这里返回的元素的宽高是包含元素的border-width和padding的，因为盒子默认的是标准盒模型（standard box），如果设置了box-sizing：border-box的话，则获取到的宽高只包含元素内容的宽高。</p><h4 id="DOMRect对象"><a href="#DOMRect对象" class="headerlink" title="DOMRect对象"></a>DOMRect对象</h4><p>DOMRect对象描述了一个矩形的大小和位置，属性都是只读的。</p><p>通过mdn上的一个demo看一下都有哪些属性吧:</p><p>html</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;div&gt;</span><span class="hljs-section">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p>javascript</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-built_in">rect</span> = elem.getBoundingClientRect();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">rect</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">rect</span>[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> para = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);<br>    para.textContent  = <span class="hljs-string">`<span class="hljs-subst">$&#123; key &#125;</span> : <span class="hljs-subst">$&#123; rect[key] &#125;</span>`</span>;<br>    <span class="hljs-built_in">document</span>.body.appendChild(para);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codepen.io/yanglusen/pen/YzEVGgq">传送门</a></p><p>运行结果如下：</p><p><img src="/img/calculate/result.png"></p><p>这里的width属性正是我们想要的元素的宽度。</p><p>这里解释下，代码里没有设置margin:8px,为什么会有8像素的margin呢，是以为codePen这个在线编辑器的body有默认的8px的margin。</p><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>其实知道了关键的方法代码也就出来了，如下这是ts的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算字符串的像素长度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>str 输入的字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fontSize 字体大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>输入字符串的像素长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> getTextWidth(str: <span class="hljs-built_in">string</span>,<span class="hljs-attr">fontSize</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span> &#123;<br> <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br> ele.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;<br> ele.style.whiteSpace = <span class="hljs-string">&#x27;nowrap&#x27;</span>;<br> ele.style.fontSize = fontSize;<br> ele.style.fontFamily = <span class="hljs-string">&#x27;inherit&#x27;</span>;<br> ele.style.opacity = <span class="hljs-string">&#x27;0&#x27;</span>;<br> ele.innerText = str;<br> <span class="hljs-built_in">document</span>.body.append(ele);<br> result = ele.getBoundingClientRect().width;<br> <span class="hljs-built_in">document</span>.body.removeChild(ele);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是字符串的字体样式如fontFamily、fontSize等都会影响其宽度的，因为我的需求中字体都是Chrome默认的，只有大小会不同，所以单独把字体大小作为形参提了出来。</p><p>笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ng-zorro中实现两个table同步滚动效果</title>
    <link href="/2022/01/19/ng-zorro%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AAtable%E5%90%8C%E6%AD%A5%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <url>/2022/01/19/ng-zorro%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AAtable%E5%90%8C%E6%AD%A5%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>某天下午，同事向我请教了一个问题，需求是有两个table，当table存在滚动条时，在某一个table上滚动，那么另一个table也要同步滚动，巧的是我也不会，但是我闲着没事，帮着研究了一下。</p><p>技术栈是： angular8 + ng-zorro组件库</p><p>先看效果和代码：</p><p><img src="/img/ng-zorro-scroll/scroll.gif"></p><p>html代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;syn-margin-left-24&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex;&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">nz-table</span> [<span class="hljs-attr">nzData</span>]=<span class="hljs-string">&quot;leftData&quot;</span>  [<span class="hljs-attr">nzScroll</span>]=<span class="hljs-string">&quot;&#123;y: &#x27;300px&#x27;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 95%;&quot;</span> [<span class="hljs-attr">nzShowPagination</span>]=<span class="hljs-string">false</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> &gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> &gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> &gt;</span>Address<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let data of leftData&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.age</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">nz-table</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">nz-table</span> [<span class="hljs-attr">nzData</span>]=<span class="hljs-string">&quot;rightData&quot;</span> [<span class="hljs-attr">nzScroll</span>]=<span class="hljs-string">&quot;&#123;y: &#x27;300px&#x27;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 95%;&quot;</span> [<span class="hljs-attr">nzShowPagination</span>]=<span class="hljs-string">false</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Address<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let data of rightData&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.age</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">nz-table</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>ts代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; StorageUtil &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./../shared/utils/storage-util&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; AfterViewInit, Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  name?: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>  address?: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-meta">@Component</span>(&#123;<br>  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-dashboard&#x27;</span>,<br>  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./dashboard.component.html&#x27;</span>,<br>  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;./dashboard.component.scss&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">AfterViewInit</span> </span>&#123;<br>  <span class="hljs-attr">leftData</span>: Person[] = <span class="hljs-built_in">this</span>.generateItems(<span class="hljs-string">&#x27;Edward King&#x27;</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;London, Park Lane no.&#x27;</span>,<span class="hljs-number">25</span>);<br>  rightData: Person[] = <span class="hljs-built_in">this</span>.generateItems(<span class="hljs-string">&#x27;John Brown&#x27;</span>,<span class="hljs-number">42</span>,<span class="hljs-string">&#x27;New York No. 1 Lake Park&#x27;</span>,<span class="hljs-number">15</span>);<br>  ngAfterViewInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.ant-table-body&#x27;</span>);<br>    <span class="hljs-keyword">const</span> leftTable = element[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> rightTable = element[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> scale = (leftTable.scrollHeight - leftTable.clientHeight) / (rightTable.scrollHeight - rightTable.clientHeight);<br>    <span class="hljs-keyword">if</span> (leftTable?.scrollHeight &amp;&amp; leftTable.clientHeight &amp;&amp; leftTable?.scrollHeight &amp;&amp; leftTable.clientHeight) &#123;<br>      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>      leftTable.addEventListener(<span class="hljs-string">&#x27;mouseover&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        leftTable.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (!flag) &#123;<br>            rightTable.scrollTop = leftTable.scrollTop / scale;<br>            rightTable.scrollLeft = leftTable.scrollLeft;<br>          &#125;<br>        &#125;)<br>      &#125;);<br>      rightTable.addEventListener(<span class="hljs-string">&#x27;mouseover&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        rightTable.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (flag) &#123;<br>            leftTable.scrollTop = rightTable.scrollTop * scale;<br>            leftTable.scrollLeft = rightTable.scrollLeft;<br>          &#125;<br>        &#125;)<br>      &#125;);<br>    &#125;<br>  &#125;<br>  generateItems(name: <span class="hljs-built_in">string</span>,<span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span>,<span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>): Person[] &#123;<br>    <span class="hljs-keyword">const</span> res: Person[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      res.push(<br>        &#123;<br>         <span class="hljs-attr">name</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span><span class="hljs-subst">$&#123;i&#125;</span>`</span>,<br>         <span class="hljs-attr">age</span>: age + i,<br>         <span class="hljs-attr">address</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;address&#125;</span><span class="hljs-subst">$&#123;i&#125;</span>`</span><br>        &#125;<br>      )<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看ts代码的第23行，querySelectAll()方法可以获取所有class名为”ant-table-body”的元素，这个class是ng-zorro框架内部的类，可以通过浏览器的审查元素看到：</p><p><img src="/img/ng-zorro-scroll/ng-zorro-scroll-1.png"></p><p>可能你会有疑问为什么我会找这个class呢？这是因为我们要监听存在滚动条的容器的scroll事件，所以自然的要找到这个容器。</p><p>现在已经把Dom找出来了，下一步就是设置让两个table的scrollTop和scrollLeft的值相同即可。</p><p>有两个需要注意的地方：</p><ol><li><p>上面的代码我们设置了个flag值，是为了防止左右两个table相互赋值导致滑动缓慢，同时也可减少浏览器的性能消耗，你可以去掉flag字段看看，滑动会变卡。</p></li><li><p>scale值是为了防止两个table的高度不一样设置的，这样的话滑动的时候两个table会同时到达底部或顶部。如果两个table的高度相同那scale就没啥意义了，加不加都一样。</p></li></ol><p>完整的思路如下：</p><ol><li><p>找到关键点，使两个table同步滚动的关键就是找到并设置两个table滚动区域的scrollTop、scrollLeft的值相同即可。</p></li><li><p>因为用的是ng-zorro框架，所以通过审查元素定位到某个div。</p></li><li><p>通过querySelectorAll()方法获取两个table的dom对象，获取dom对象的方式有很多种，在这里只能用querySelectorAll()方法。</p></li><li><p>添加监听事件，先监听mouseover再监听scroll事件。</p></li><li><p>设置两个容器的scrollTop和scrollLeft的值相同。</p></li><li><p>考虑反思有没有问题，比如两个table高度不一样等，然后再想怎么完善。</p></li></ol><p>解决该问题用到了很多基础的js的知识，比如原生的鼠标监听事件，mouseover、scroll等，还有scrollTop、scrollHeigh、clientHeight等属性的理解，由此看出有一个好的基础还是挺重要的！</p><p>以上。笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
      <tag>ng-zorro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中的repeat函数的用法</title>
    <link href="/2022/01/18/css%E4%B8%AD%E7%9A%84repeat%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2022/01/18/css%E4%B8%AD%E7%9A%84repeat%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在学习css的过程中发现css是真的难，可能某一个属性就得去深究半天，不积跬步无以至千里，遇到不会的且觉着有深度的问题尽量学习记录一下吧。今天来看一下css中的repeat()函数。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先看MDN的定义吧：</p><blockquote><p>CSS repeat() 函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows.</p></blockquote><p>我个人的理解: grid布局中grid-template-columns 和 grid-template-rows 两个属性分别是定义网格的列数和行数，如果定义大量的重复宽度的行或列就可以用到这个函数简化了，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br><br>// 等同于<br><br>grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>,<span class="hljs-number">100px</span>);<br></code></pre></td></tr></table></figure><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>定义其实不难，重点是它的语法和使用，尤其是当它与关键字结合时会有意想不到的效果。</p><p>repeat函数所有的取值如下：</p><ol><li><p>正整数长度。如 100px、10vw等</p></li><li><p>百分比，相对于网格容器块的大小的百分比。如 10%</p></li><li><p>带有 fr 单位的非负尺寸指定轨道的弹性系数。 如 1fr</p></li><li><p>max-content 关键字，代表占据网格轨道的网格项目所分配的最大内容区域的最大值。</p></li><li><p>min-content 关键字，代表占据网格轨道的网格项目所分配的最小内容区域的最小值。</p></li><li><p>auto 关键字，作为最大值，等同于 max-content。作为最小值，它代表占据网格轨道的网格项目的最小尺寸的最大值 （如同min-width/min-height所指定的)）。</p></li><li><p>auto-fill 关键字，内容自动填充，具体解释和下面的auto-fit关键字一起说。</p></li><li><p>auto-fit 关键词，内容自动适应。</p></li></ol><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>网格划分成4列，比例为1:1:1:1</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repeat</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><p><img src="/img/repeat/repeat-demo-1.png"></p><p><a href="https://codepen.io/yanglusen/pen/PoJXdgj">Demo传送门</a></p><ol start="2"><li>使用关键字 min-content/max-content</li></ol><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>,<span class="hljs-built_in">min</span>-content);<br><br><span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>,<span class="hljs-built_in">max</span>-content);<br></code></pre></td></tr></table></figure><p>1）先看min-content的代码和示例图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-containter&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>grid grid grid grid grid grid grid grid grid grid<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAAAAAAAAAAAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAAAAAAAAAAAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAAAA BBBBBB<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>cc<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>cc<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-containter</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50vw</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">220px</span>;<br>  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>,min-content);<br>  place-items: center;<br>  gap: <span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> transparent;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#F89427</span>;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例图：</p><p><img src="/img/repeat/repeat-demo-2.png"></p><p><a href="https://codepen.io/yanglusen/pen/YzrdJOE">Demo传送门</a></p><p><strong>对于min-content这个关键词我个人觉着是不太好理解的，如果看完代码和示例图有疑问的话可到文末看对于这个关键词的单独分析。</strong></p><p>2）再看max-content的代码和示例图</p><p>代码只需要改动css中的一行，把 min-content 替换成 max-content</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: repeat(<span class="hljs-number">4</span>,<span class="hljs-built_in">max</span>-<span class="hljs-built_in">content</span>);<br></code></pre></td></tr></table></figure><p>示例图</p><p><img src="/img/repeat/repeat-demo-2-2.png"></p><p>可以看到它们之间的区别，只有第一个div的宽度变大了，是因为此max-content取得是第一个p标签的宽度作为div的宽度。而min-content取得是最后一个p标签的宽度。</p><p>3.固定某列宽度，其它列按比例平分</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: <span class="hljs-number">400</span>px repeat(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><p><img src="/img/repeat/repeat-demo-3.png"></p><p><a href="https://codepen.io/yanglusen/pen/bGoOQLN">Demo传送门</a></p><ol start="4"><li>使用minmax函数，设置列的最大、最小值</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr));<br></code></pre></td></tr></table></figure><ol start="4"><li>使用关键字 auto-fill/auto-fit</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr));<br><br>grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr));<br></code></pre></td></tr></table></figure><p>auto-fill</p><p><img src="/img/repeat/repeat-demo-4.png"></p><p>auto-fit</p><p><img src="/img/repeat/repeat-demo-5.png"></p><p>auto-fill和auto-fit的区别从它们的名字上就能看出来，一个是自动填充，一个是自动适应，看一下国外大佬的解释：</p><blockquote><p>auto-fill: 填充尽可能多的列。因此，只要新列可以容纳，它就会创建隐式列，因为它试图用尽可能多的列填充行。新添加的列可以也可能是空的，但它们仍将占据行中的指定空间。</p></blockquote><blockquote><p>auto-fit: 适合当前可用列的空间扩大，以便他们占用任何可用的空间。浏览器在用额外的列填充这些额外的空间之后(如自动填充) ，然后折叠空的列。</p></blockquote><p><a href="https://codepen.io/yanglusen/pen/poWYPKq">Demo传送门</a></p><p><img src="/img/repeat/repeat-demo-4-1.png"></p><p>如上图：当容器空间充足时，auto-fill会隐式的创建更多的列。</p><h3 id="min-content关键词"><a href="#min-content关键词" class="headerlink" title="min-content关键词"></a>min-content关键词</h3><p>为什么把min-content关键词单独拿出来说，我查了很多资料并没有很好的解释到位，而且我发现网上还有一些关于它的demo的理解是错误的，所以特此解释一下我的理解：</p><p>看MDN的解释：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The <span class="hljs-built_in">min</span>-content sizing keyword represents <span class="hljs-keyword">the</span> intrinsic minimum width <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> content. For <span class="hljs-keyword">text</span> content this means that <span class="hljs-keyword">the</span> content will take all soft-wrapping opportunities, becoming <span class="hljs-keyword">as</span> small <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> longest <span class="hljs-built_in">word</span>.<br></code></pre></td></tr></table></figure><p>这个是英文版的，为什么不看中文版的呢？因为中文版的内容没有及时更新，至少截止到我写这篇文章的时候是没有的。</p><p>大概的意思就是min-content 关键字表示内容固有的最小宽度，对于文本而言，最小宽度则是最长单词的宽度。懂了吗？如果一个容器内的内容是文本，如果用了min-content关键字，那么该容器的宽度则取容器内单词最长的文本的宽度，而不是单词最短的那个，这里还有一个坑就是，对于中文而言，一个字就是一个“词”，而对于英文和数字，则是根据空格来区分一个词的。比如 “HelloWorld”这是一个词。</p><p>再看上文中的例子就可以理解了吧？</p><p>以上，虽然文章标题是repeat函数，但是并不只是讲了repeat函数，笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p><p>参考资料：</p><p><a href="https://css-tricks.com/auto-sizing-columns-css-grid-auto-fill-vs-auto-fit/">Auto-Sizing Columns in CSS Grid: <code>auto-fill</code> vs <code>auto-fit</code></a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/min-content">MDN min-content</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>repeat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中的linear-gradient函数的用法</title>
    <link href="/2021/12/30/css%E4%B8%AD%E7%9A%84linear-gradient%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2021/12/30/css%E4%B8%AD%E7%9A%84linear-gradient%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>日常工作中用到了渐变色，但是仅限于了解实现简单的效果，所以趁着有空好好学习一番。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MDN的解释：</p><blockquote><p>CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于&lt;gradient&gt;数据类型，是一种特别的&lt;image&gt;数据类型。</p></blockquote><p>linear-gradient其实就是相当于background-image，它创建的是背景图片而非背景色。</p><h4 id="渐变角度"><a href="#渐变角度" class="headerlink" title="渐变角度"></a>渐变角度</h4><p>渐变角度是与渐变容器中心点的垂线形成的角度。</p><h4 id="渐变线"><a href="#渐变线" class="headerlink" title="渐变线"></a>渐变线</h4><blockquote><p>渐变线由包含渐变图形的容器的中心点和一个角度来定义的。渐变线上的颜色值是由不同的点来定义，包括起始点，终点，以及两者之间的可选的中间点（中间点可以有多个）</p></blockquote><p>如下图：</p><p><img src="/img/linear-gradient/gradient-1.png"></p><p>点C为渐变容器的中心点，角度A是与过C点的垂线形成的角度，穿过中心点形成渐变角的这条线就叫做渐变角度。</p><p><strong>渐变线和渐变角度相辅相成，它们之间可以根据彼此互相计算得到。</strong></p><h4 id="起始点"><a href="#起始点" class="headerlink" title="起始点"></a>起始点</h4><blockquote><p>起始点是渐变线上代表起始颜色值的点。起始点由渐变线和过容器顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内）</p></blockquote><h4 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h4><blockquote><p>终点是渐变线上代表最终颜色值的点。终点也是由渐变线和从最近的顶点发出的垂直线之间的交叉点定义的，然而从起始点的对称点来定义终点是更容易理解的一种方式，因为终点是起点关于容器的中心点的反射点。</p></blockquote><p>如下图：</p><p><img src="/img/linear-gradient/gradient-2.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>先看MDN：</p><p><img src="/img/linear-gradient/gradient-3.png"></p><blockquote><p><strong>&lt;side-or-corner&gt;</strong><br>描述渐变线的起始点位置。它包含to和两个关键词：第一个指出水平位置left or right，第二个指出垂直位置top or bottom。关键词的先后顺序无影响，且都是可选的。<br>to top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p></blockquote><blockquote><p><strong>&lt;angle&gt;</strong><br>用角度值指定渐变的方向（或角度）。角度顺时针增加。 </p></blockquote><blockquote><p><strong>&lt;linear-color-stop&gt;</strong><br>由一个<color>值组成，并且跟随着一个可选的终点位置（可以是一个百分比值或者是沿着渐变轴的<length>）</p></blockquote><blockquote><p><strong>&lt;color-hint&gt;</strong><br>颜色中转点是一个插值提示，它定义了在相邻颜色之间渐变如何进行。长度定义了在两种颜色之间的哪个点停止渐变颜色应该达到颜色过渡的中点。如果省略，颜色转换的中点是两个颜色停止之间的中点。</p></blockquote><p>太多？看不懂？没关系：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Value_definition_syntax">教你读懂MDN上的CSS语法</a></p><p>简单的总结一下语法：</p><table><thead><tr><th>值</th><th align="center">描述</th></tr></thead><tbody><tr><td>方向</td><td align="center">定义渐变色的渐变方向（角度）,其值可选，默认值是180deg（to bottom）</td></tr><tr><td>渐变色</td><td align="center">至少由两个颜色组成，每个颜色后面跟着可选参数，表示两个颜色之间渐变色的起点，如：linear-gradient(red 10%, blue 90%)，表示从起点到10%的距离为红色，10%-90%的距离为从红色渐变到蓝色，90%-终点为蓝色。每两个颜色中间还有一个可选参数，代表两个颜色转换的中点，默认50%，如10% - 90% 这段渐变距离的中点就是两个颜色的转换的中点</td></tr></tbody></table><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>列举该函数所有可能性的用法：</p><ol><li>第一个参数不写,默认180deg，从上到下渐变</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">background</span>: linear-gradient(<span class="hljs-built_in">red</span>, <span class="hljs-built_in">blue</span>);<br><br><span class="hljs-comment">// 等同于：</span><br><br><span class="hljs-built_in">background</span>: linear-gradient(<span class="hljs-number">180</span>deg, <span class="hljs-built_in">red</span>, <span class="hljs-built_in">blue</span>);<br><br><span class="hljs-built_in">background</span>: linear-gradient(to bottom, <span class="hljs-built_in">red</span>, <span class="hljs-built_in">blue</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-4.png"></p><p><strong><a href="https://codepen.io/yanglusen/pen/yLzRpNR">Demo传送门</a></strong></p><ol start="2"><li>带第一个参数，45度渐变</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, red, blue);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-5.png"></p><p><strong><a href="https://codepen.io/yanglusen/pen/MWEPrgP">Demo传送门</a></strong></p><ol start="3"><li>渐变色后跟可选参数，表示渐变的距离</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(red <span class="hljs-number">20%</span>, blue <span class="hljs-number">80%</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-6.png"></p><p><strong><a href="https://codepen.io/yanglusen/pen/eYGPymx">Demo传送门</a></strong></p><ol start="4"><li>每两个渐变色之间跟可选参数，表示两个颜色间渐变的中心点</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">background</span>: linear-gradient(red <span class="hljs-number">20</span>%, <span class="hljs-number">60</span>%, blue <span class="hljs-number">80</span>%);<br></code></pre></td></tr></table></figure><p><img src="/img/linear-gradient/gradient-7.png"></p><p><strong><a href="https://codepen.io/yanglusen/pen/MWEPOLB">Demo传送门</a></strong></p><p>再解释一下，渐变中心：从上到下，20%到80%为容器的渐变距离，然后如果不设置渐变中心，默认50%，也就是说20%到80%之间距离的中心也就是两个颜色正式改变的位置，如上，我设置了渐变中心为60%的位置，也就是说红色渐变的距离长，颜色改变的慢。</p><p>以上。笔者水平有限，若有错误敬请指正，不明白的地方也可评论区留言交流~</p><p>参考资料：</p><p><a href="https://www.w3cplus.com/css3/do-you-really-understand-css-linear-gradients.html">你真的理解CSS的linear-gradient？</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/linear-gradient()">MDN—CSS linear-gradient()函数</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>linear-gradient</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
